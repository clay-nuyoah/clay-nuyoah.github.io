<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0-1 背包问题</title>
    <url>/2021/01/22/0-1-bei-bao/</url>
    <content><![CDATA[<p>使用动态规划解决 0-1 背包问题</p>
<a id="more"></a>

<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>有 n 个物品，它们有各自的重量和价值，现有给定容量的背包，</p>
<p>如何让背包里装入的物品具有最大的价值总和？（注意：每种物品只能放入到背包中一次）</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/12/11-23-18-d873196dcb9b54a1001a4559f2d350a3-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210312111327-2d3f85.png"></p>
<p>上图给出了 a、b、c、d 4 种物品以及每种物品对应的体积和价值。</p>
<p>我们将要求体积为 8 的背包最多可以存放多大的价值。</p>
<h1 id="二、预备知识"><a href="#二、预备知识" class="headerlink" title="二、预备知识"></a>二、预备知识</h1><p><strong>1、将使用 w(i) 表示物品 i 的重量，如</strong></p>
<pre><code>w(a) 表示物品 a 的重量
w(b) 表示物品 b 的重量
w(c) 表示物品 c 的重量
w(d) 表示物品 d 的重量</code></pre>
<p><strong>2、将使用 v(i) 表示物品 i 的价值，如</strong></p>
<pre><code>v(a) 表示物品 a 的价值
v(b) 表示物品 b 的价值
v(c) 表示物品 c 的价值
v(d) 表示物品 d 的价值</code></pre>
<p><strong>3、dp[i][j] 的含义</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/13/16-22-44-933b8ac26bb816025a4e8ec066c5dfca-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210313161113-0977f1.png"></p>
<p>上图为初始化时，动态规划所用到的 dp 数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/14/21-55-23-e50b7b34bc1fb1d530cf9d57686242b6-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210312111818-eb374c.png"></p>
<p>上图为动态规划执行完毕之后得到的二维数组 dp，怎么构建该数组会在下面介绍，</p>
<p>这里先不用先关注计算的过程</p>
<p>我们使用二维数组 dp 表示动态规划需要构造的数组，其中 dp[i][j] 表示，</p>
<p>当背包的<strong>容量为 j</strong> 时，且只有<strong>前 i 件</strong>物品时，</p>
<p>背包里装入物品的<strong>最大</strong>的价值总和为 <strong>dp[i][j]</strong></p>
<p><strong>4、对于 dp[i][j] 的进一步解释</strong></p>
<p>对于本题来说，我们假设</p>
<pre><code>a 为第一件商品        b 为第二件商品        c 为第三件商品        d 为第四件商品</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/14/20-06-20-6ac242d1cdca69d1d5d7005911f49f6e-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210314200427-a67598.png"></p>
<p>图中标黄的值可以用 dp[3][7] = 9 表示</p>
<p>她所代表的含义是当背包的容量为 7 时，且只有前 3 件物品时，</p>
<p>背包里装入物品的最大价值总和为 9，</p>
<p>dp[3][7] = 9 需要注意到的重点</p>
<pre><code>1、只有前 3 件商品，即 a b c 这三件商品，即使物品的总数量为 4，但是就 dp[3][7]

来说只能取前三件，要是需要取全部的 4 件商品，需要求 dp[4][7]

2、背包的容量是 7，即使背包总容量是 8，但是就 dp[3][7] 来说，目前背包的容量为 7

3、p[3][7] 表示 当只有前 3 件商品时，并且背包的容量为 7 时，

背包里面能装的最大价值为 9，这里的 9 表示的是最大价值，是一个最优的结果，

无论前三种商品怎么组合，在现有的容量下，能够得到的最大价值是 9</code></pre>
<p><strong>5、动态规划矩阵（即 dp 矩阵）计算的方向</strong></p>
<p>我们在计算 dp 矩阵的时候，计算的方向是从上到下，从左到右依次计算的</p>
<p>这又有什么意义呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/13/16-51-17-c164af316dee7f8f802a27336cecf586-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210313164831-7bafeb.png"></p>
<p>假设我们需要计算图中标黄的值（该值可以用 dp[2][4] 表示），</p>
<p>按照从上到下，从左到右的计算方向，计算的顺序是</p>
<pre><code>dp[0][0] -&gt; dp[1][0] -&gt; dp[2][0] -&gt; dp[3][0] -&gt; dp[4][0] -&gt; 
dp[0][1] -&gt; dp[1][1] -&gt; dp[2][1] -&gt; dp[3][1] -&gt; dp[4][1] -&gt;
dp[0][2] -&gt; dp[1][2] -&gt; dp[2][2] -&gt; dp[3][2] -&gt; dp[4][2] -&gt; 
dp[0][3] -&gt; dp[1][3] -&gt; dp[2][3] -&gt; dp[3][3] -&gt; dp[4][3] -&gt;
dp[0][4] -&gt; dp[1][4] -&gt; dp[2][4]</code></pre>
<p>也就是说在计算 标黄值位置的时候，标绿值的位置已经全部都计算完毕了</p>
<p><strong>6、数据动态变化的过程</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/13/16-51-17-c164af316dee7f8f802a27336cecf586-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210313164831-7bafeb.png"></p>
<p>还是拿着上图标黄的值来搞事情</p>
<p>计算 dp[2][4] = 4 的原因</p>
<p>根据计算方向，求完了 dp[1][4] = 3 才能求 dp[2][4] = 4,</p>
<p>dp[1][4] = 3 说明了当背包的容量为 4 时，</p>
<p>如果我有前 1 件商品（即 只有 a 商品），背包中能存放的最大价值为 3，</p>
<p>但是在计算 dp[2][4] 时，由计算 a 这一件商品变成了计算 a b 两件商品</p>
<p>这是我们需要在 a b 中选择物品添加到背包中，</p>
<p>背包还是那个背包（容量没有发生变化），这时背包能存放的总价值变成了 4。</p>
<p>这就是由 dp[1][4] -&gt; dp[2][4] 的过程</p>
<h1 id="三、对于公式的理解"><a href="#三、对于公式的理解" class="headerlink" title="三、对于公式的理解"></a>三、对于公式的理解</h1><p>几乎在所有的博客之中都会出现下列公式，那么就让我来给你解释一下它的意义；</p>
<pre><code>dp[i][j] = max &#123; dp[i - 1][j], dp[i - 1][j - w[i]] + v[i] &#125;</code></pre>
<p>在 <strong>二、符号化</strong>中 我们已经介绍了 w[i] 和 v[i] 的含义，</p>
<p>其中 w[i] 表示物品 i 的重量，v[i] 表示物品 i 的价值</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/13/16-51-17-c164af316dee7f8f802a27336cecf586-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210313164831-7bafeb.png"></p>
<p>物品的体积和价值图</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/12/11-23-18-d873196dcb9b54a1001a4559f2d350a3-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210312111327-2d3f85.png"></p>
<p>上图中 </p>
<pre><code>dp[2][4] = max &#123; dp[2 - 1][4],dp[2 - 1][4 - w(b)] + v(b) &#125;

= max&#123;dp[1][4],dp[1][1] + 4&#125; = max&#123;3，4&#125; = 4</code></pre>
<p>影响 dp[2][4] 值大小的影响因素有两个，一个是 dp[1][4]，另一个是 dp[1][1] + 4，</p>
<p>下面分别介绍两部分的值是如何得到的。</p>
<h2 id="1、当物品-b-出现时，背包装不下-（此处是用来求-dp-1-4-大小）"><a href="#1、当物品-b-出现时，背包装不下-（此处是用来求-dp-1-4-大小）" class="headerlink" title="1、当物品 b 出现时，背包装不下 （此处是用来求 dp[1][4] 大小）"></a>1、当物品 b 出现时，背包装不下 （此处是用来求 dp[1][4] 大小）</h2><p><strong>1、dp[1][4] 是如何来的</strong></p>
<p>当物品 b 出现时，背包的容量已经放不下物品 b 了，</p>
<p>这时背包能够存放的最大价值就是只有前 1 件货物（即只有货物 a）时所能存放最大价值，</p>
<p>因为没法把 b 放入到背包，所以背包存放的最大价值不会发生改变</p>
<p>背包的总价值就是前 1 件物品（只有货物 a）的总价值，即 dp[1][4]</p>
<p><strong>2、知识延申</strong></p>
<p>dp[i][j] 在这种情况下可以表示为，</p>
<p>当物品 i 出现时，背包的容量已经放不下物品 i 了，</p>
<p>这时背包能够存放的最大价值就是只有前 i - 1 件货物时所能存放最大价值，</p>
<p>因为没法把 i 放入到背包，所以背包存放的最大价值不会发生改变，</p>
<p>背包的容量为 j 时，背包的总价值就是只有前 i - 1 时的最大价值</p>
<p>我们知道 dp[i-1][j] 就代表了背包的容量为 j 时，背包的总价值就是只有前 i - 1 时的最大价值</p>
<p>所以公式中前一部分搞定了，即图中划红线的部分</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/13/17-52-16-63dc62414102a1b76abc36f254cabe4e-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210313171644-5652a0.png"></p>
<h2 id="2、当物品-b-出现时，背包能装下-（此处是用来求-dp-1-1-4-的大小）"><a href="#2、当物品-b-出现时，背包能装下-（此处是用来求-dp-1-1-4-的大小）" class="headerlink" title="2、当物品 b 出现时，背包能装下 （此处是用来求 dp[1][1] + 4 的大小）"></a>2、当物品 b 出现时，背包能装下 （此处是用来求 dp[1][1] + 4 的大小）</h2><p><strong>1、dp[1][1] + 4 是如何来的</strong></p>
<p>当物品 b 出现时，物品 b 能够放入到背包中，那么背包就要留出一定的空间，</p>
<p>那么需要留出多大的空间呢？</p>
<p>留出的空间的大小是刚好能够容纳 b，这样可以充分利用背包中的空间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/12/11-23-18-d873196dcb9b54a1001a4559f2d350a3-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210312111327-2d3f85.png"></p>
<p>就本题而言，w(b) = 3,也就是说我们再没有把 b 放入背包之前需要留出 3 的空间大小</p>
<p><strong>重点强调</strong></p>
<pre><code>1、因为要留出空间来存放 b，所以要在 b 未放入之前为 b 留出空间
2、留出空间的大小为 3，因为这样刚好能够放下 b
3、若要能满足以上的条件，我们从满足添加的数据里面挑选一个价值最大的数据就行了</code></pre>
<p>对于本题来说，我们要保证在背包容量小于等于 1（即 4 - w(b) = 4 - 3 = 1） 的时候，</p>
<p>才能安全的把 b 物品放入到背板</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/13/17-30-07-cce8c6e9fdf6024371afeaa913deeab8-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210313172958-9bf56e.png"></p>
<p>我们用上图来分析一下那些区域可以放 c 物品，图中蓝色区域是已经有了 b 货物，所以不能选，</p>
<p>橙色区域表示<strong>若</strong>我们把 b 物品放入到背包中，背包的容量是放不下的，</p>
<p>绿色区域是安全区域，我们可以安全的把 b 货物放入到背包,</p>
<p>对于 dp[0][0],dp[1][0] 和 dp[0][1],dp[1][1],我们要选dp[0][1],dp[1][1],因为 背包的容量大啊，能装的东西就多啊，能得到的价值就多啊，你 dp[0][0],dp[1][0],能装的 我 dp[0][1],dp[1][1] 都能装啊，而且我还能比你更能装。</p>
<p>但是对于 dp[0][1],dp[1][1] 这两个值，我们要选择 dp[1][1],因为 dp[0][0] 是在前 0 种物品中选取物品，而我们要把第 2 件商品放入背包之前，是要在前 1 件物品中选择物品的</p>
<p>我们选择了 dp[1][1],这是背包有多余的空间放入 b 物品，这时将 b 物品放入背包，</p>
<p>这时背包的最大价值为 dp[1][1] + v(b) = dp[1][1] + 4 = 4</p>
<p><strong>2、知识延申</strong></p>
<p>dp[i][j] 在这种情况下可以表示为，</p>
<p>当物品 i 出现时，物品 i 能够放入到背包中，那么背包就要留出一定的空间,</p>
<p>留出的空间大小为 w(i)，保证背包的容量为 j - w（i） 这样刚好放下物品 i</p>
<p>而且还要在前 i - 1 件货物中挑选物品，</p>
<p>而且还要保证得到最大的价值，只能选择 dp[i - 1][j - w(i)]</p>
<p>选择了 dp[i - 1][j - w(i)] 之后，物品 i 就可以放入到背包中了，</p>
<p>这时背包的最大价值就是 dp[i - 1][j - w(i)] + v[i]</p>
<p>这里解释了公式的后半部分</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/14/21-57-56-36765a6a260f1f821c9a354d159dad03-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210314215731-a22cca.png"></p>
<h2 id="3、补充"><a href="#3、补充" class="headerlink" title="3、补充"></a>3、补充</h2><p><strong>1、当背包中容量留不出第 i 件物品需要的空间</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/15/19-47-47-e5ad3d771ad98712fe209446bf94040f-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210315193253-f27007.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/12/11-23-18-d873196dcb9b54a1001a4559f2d350a3-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210312111327-2d3f85.png"></p>
<p>图中标绿的位置可以使用 dp[2][2] = 3 表示，按照上述公式，该位置为</p>
<pre><code>dp[2][2] = max&#123; dp[1][2], dp[1][2 - w(b)] + v(a) &#125;</code></pre>
<p>由于在后半部分 2 - w(b) 2 - 3 &lt; -1 &lt; 0,这说明无论背包怎么留空间都不足以给物品 b 留出足够的空间，</p>
<p>所以这时候 dp[2][2] 只来自于第一部分，即 dp[2][2] = dp[1][2]</p>
<p>在完善以下上述公式可以得到如下公式：</p>
<pre><code>dp[i][j] = max &#123; dp[i - 1][j], dp[i - 1][j - w(i)] + v(i) &#125;  j - w(i) &gt;=0
dp[i][j] = dp[i - 1][j]                                         j - w(i) &lt; 0</code></pre>
<h1 id="四、对于本题来说完整的执行过程"><a href="#四、对于本题来说完整的执行过程" class="headerlink" title="四、对于本题来说完整的执行过程"></a>四、对于本题来说完整的执行过程</h1><p>下述的所有过程会在代码中体现出来</p>
<h2 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h2><p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/15/20-00-43-80fd021643237a39faff9da800387918-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210315195715-b52a66.png"></p>
<p>将上图中标记为绿色和黄色的部分初始化为 0</p>
<p><strong>这样做的好处</strong></p>
<p>1、便于计算，不如说我们在计算橙色位置 dp[1][1] 的时候，</p>
<p>这时候背包的总容量时小于 a 的体积的，所以无法留出阻攻的空间来存放物品 a，</p>
<p>所以根据公式该处的位置直接是 dp[1][1] = dp[0][1] = 0</p>
<p>这样可以省略一些判断</p>
<p>2、也符合逻辑，绿色部分表示，一件物品都没有，所以背包能存放的最大价值为 0，</p>
<p>因为没有东西可以往背包中放；黄色部分表示，背包的容量为 0，</p>
<p>这时候无论什么物品都没法放入到背包中，所以背包能存放的最大价值为 0</p>
<h2 id="2、第一部分计算"><a href="#2、第一部分计算" class="headerlink" title="2、第一部分计算"></a>2、第一部分计算</h2><p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/15/20-29-45-49d1af40a82559ce820b70c206a3ea88-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210315202934-73abd8.png"></p>
<p>对于上图来说，灰色部分表示已经计算完毕的部分，绿色部分表示即将要计算的部分</p>
<p>他们分别用 dp[1][1],dp[2][1],dp[3][1],dp[4][1] 表示</p>
<p>物品的体积和价值表</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/12/11-23-18-d873196dcb9b54a1001a4559f2d350a3-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210312111327-2d3f85.png"></p>
<p><strong>对于 dp[1][1]</strong></p>
<p>判断背包能不能留出足够的空间</p>
<p>利用公式 j - w(a) = 1 - 2 = -1 &lt; 0（背包留不出足够的空间)</p>
<p>所以有</p>
<pre><code>dp[1][1] = dp[1 - 1][1] = dp[0][1] = 0</code></pre>
<p><strong>对于 dp[2][1]</strong></p>
<p>判断背包能不能留出足够的空间</p>
<p>利用公式 j - w(b) = 1 - 3 = -2 &lt; 0（背包留不出阻攻的空间）</p>
<pre><code>dp[2][1] = dp[2 - 1][1] = dp[1][1] = 0</code></pre>
<p><strong>对于 dp[3][1]</strong></p>
<p>判断背包能不能留出足够的空间</p>
<p>利用公式 j - w(c) = 1 - 4 = -3 &lt; 0（背包留不出阻攻的空间）</p>
<pre><code>dp[3][1] = dp[3 - 1][1] = dp[2][1] = 0</code></pre>
<p><strong>对于 dp[4][1]</strong></p>
<p>判断背包能不能留出足够的空间</p>
<p>利用公式 j - w(d) = 1 - 5 = -4 &lt; 0（背包留不出阻攻的空间）</p>
<pre><code>dp[4][1] = dp[4 - 1][1] = dp[3][1] = 0</code></pre>
<p>这一列计算完毕的结果如下图，</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/15/20-46-44-c57957c93415fc3f346dc6bbfd60488d-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210315204634-84beff.png"></p>
<p>其中灰色的部分表示已经计算完毕</p>
<h2 id="3、第二部分计算"><a href="#3、第二部分计算" class="headerlink" title="3、第二部分计算"></a>3、第二部分计算</h2><p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/15/20-41-19-50918d671635b22991b8943ed889d49b-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210315204107-bd96af.png"></p>
<p>对于上图来说，灰色部分表示已经计算完毕的部分，绿色部分表示即将要计算的部分</p>
<p>他们分别用 dp[1][2],dp[2][2],dp[3][2],dp[4][2] 表示</p>
<p>物品的体积和价值表</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/12/11-23-18-d873196dcb9b54a1001a4559f2d350a3-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210312111327-2d3f85.png"></p>
<p><strong>对于 dp[1][2]</strong></p>
<p>判断背包能不能留出足够的空间</p>
<p>利用公式 j - w(a) = 2 - 2 = 0 &gt;= 0（背包能留出足够的空间)</p>
<p>所以有</p>
<pre><code>dp[1][2] = max&#123; dp[0][2],dp[0][0] + v(a) &#125; = max&#123; dp[0][2],dp[0][0] + 3 &#125;
= max&#123; 0,3 &#125; = 3</code></pre>
<p><strong>对于 dp[2][2]</strong></p>
<p>判断背包能不能留出足够的空间</p>
<p>利用公式 j - w(b) = 2 - 3 = -1 &lt; 0（背包不能留出足够的空间)</p>
<p>所以有</p>
<pre><code>dp[2][2] = dp[1][2] = 3</code></pre>
<p><strong>对于 dp[3][2]</strong></p>
<p>判断背包能不能留出足够的空间</p>
<p>利用公式 j - w(b) = 2 - 4 = -2 &lt; 0（背包不能留出足够的空间)</p>
<p>所以有<br>    dp[3][2] = dp[2][2] = 3</p>
<p><strong>对于 dp[4][2]</strong></p>
<p>判断背包能不能留出足够的空间</p>
<p>利用公式 j - w(b) = 2 - 5 = -3 &lt; 0（背包不能留出足够的空间)</p>
<p>所以有<br>    dp[4][2] = dp[3][2] = 3</p>
<p>这一列计算完毕的结果如下图，</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/15/20-52-42-756817a6e9d93cd806c4c141121bf82c-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210315205229-04c016.png"></p>
<h2 id="4、第三部分计算"><a href="#4、第三部分计算" class="headerlink" title="4、第三部分计算"></a>4、第三部分计算</h2><p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/16/20-27-07-05840f576e8afc56aacc3b91dfff63e0-20210316202555-9c8ff2.png"></p>
<p>对于上图来说，灰色部分表示已经计算完毕的部分，绿色部分表示即将要计算的部分</p>
<p>他们分别用 dp[1][3],dp[2][3],dp[3][3],dp[4][3] 表示</p>
<p>物品的体积和价值表</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/12/11-23-18-d873196dcb9b54a1001a4559f2d350a3-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210312111327-2d3f85.png"></p>
<p><strong>对于 dp[1][3]</strong></p>
<p>判断背包能不能留出足够的空间</p>
<p>利用公式 j - w(a) = 3 - 2 = 1 &gt;= 0（背包能留出足够的空间)</p>
<p>所以有<br>    dp[1][3] = max{ dp[0][3],dp[0][1] + v(a) } = max{ dp[0][3],dp[0][1] + 3 }<br>    = max{ 0,3 } = 3</p>
<p><strong>对于 dp[2][3]</strong></p>
<p>判断背包能不能留出足够的空间</p>
<p>利用公式 j - w(a) = 3 - 3 = 0 &gt;= 0（背包能留出足够的空间)</p>
<p>所以有<br>    dp[2][3] = max{ dp[1][3],dp[1][0] + v(a) } = max{ dp[1][3],dp[1][0] + 4 }<br>    = max{ 0,4 } = 4</p>
<p><strong>对于 dp[3][3]</strong></p>
<p>判断背包能不能留出足够的空间</p>
<p>利用公式 j - w(a) = 3 - 4 = -1 &lt; 0（背包能留出足够的空间)</p>
<p>所以有<br>    dp[3][3] = dp[2][3] = 4</p>
<p><strong>对于 dp[4][3]</strong></p>
<p>判断背包能不能留出足够的空间</p>
<p>利用公式 j - w(a) = 3 - 5 = -2 &lt; 0（背包能留出足够的空间)</p>
<p>所以有<br>    dp[4][3] = dp[3][3] = 4</p>
<p>这一列计算完毕的结果如下图，</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/0-1-bei-bao/2021/03/16/20-34-55-e994224c25d25b206b1abaf263b958fd-20210316203441-afeb6f.png"></p>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>动态规划</tag>
        <tag>算法</tag>
        <tag>背包问题</tag>
        <tag>0-1 背包</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划求解判断子序列问题</title>
    <url>/2020/11/24/dong-tai-gui-hua-qiu-jie-pan-duan-zi-xu-lie-wen-ti/</url>
    <content><![CDATA[<p>leetcode 题库 392 判断子序列</p>
<a id="more"></a>
<p>一、<br>①<br>        <strong>s 中的前 i 个字符是   t 中前 j 个字符的子序列，则 dp[i][j] = true<br>          s 中的前 i 个字符不是 t 中前 j 个字符的子序列，则 dp[i][j] = false</strong></p>
<p>二、<br><strong><em># 1、比较的 s 的第 i 个字符和 t 的第 j 个字符相等</em></strong></p>
<h1 id="s-的前-i-1-项是-t-的前-j-1-项的子序列"><a href="#s-的前-i-1-项是-t-的前-j-1-项的子序列" class="headerlink" title="**   s 的前 i - 1 项是 t 的前 j - 1 项的子序列**"></a>**   s 的前 i - 1 项是 t 的前 j - 1 项的子序列**</h1><pre><code>    s = &quot;abc&quot;
    t = &quot;aebc&quot;
    i = 3
    j = 4
    此时对于字符串 s 和 t 来说，最后两个字符相等
    由于 &quot;ab&quot; 是 &quot;aeb&quot; 的子序列，由 ① 得 dp[2][3] = true
    由于 s 和 t 的最后两个字符相等
    所以 &quot;abc&quot; 是 &quot;aebc&quot; 的子序列，由 ① 的 dp[3][4] = true</code></pre>
<h1 id="s-的前-i-1-项不是-t-的前-j-1-项的子序列"><a href="#s-的前-i-1-项不是-t-的前-j-1-项的子序列" class="headerlink" title="**   s 的前 i - 1 项不是 t 的前 j - 1 项的子序列**"></a>**   s 的前 i - 1 项不是 t 的前 j - 1 项的子序列**</h1><pre><code>    s = &quot;adc&quot;
    t = &quot;aebc&quot;
    i = 3
    j = 4
    此时对于字符串 s 和 t 来说,最后两个字符相等
    由于 &quot;ad&quot; 不是 &quot;aeb&quot; 的子序列，由 ① 得 dp[2][3] = false
    即使 s 和 t 的最后两个字符相等
    &quot;adc&quot; 也不是 &quot;aebc&quot; 的子序列，由 ① 的 dp[3][4] = false</code></pre>
<p><strong><em># 2、比较的 s 的第 i 个字符和 t 的第 j 个字符不相等</em></strong></p>
<h1 id="s-的前-i-项是-t-的前-j-1-项的子序列"><a href="#s-的前-i-项是-t-的前-j-1-项的子序列" class="headerlink" title="**   s 的前 i 项是 t 的前 j - 1 项的子序列**"></a>**   s 的前 i 项是 t 的前 j - 1 项的子序列**</h1><pre><code>    s = &quot;ade&quot;
    t = &quot;abdef&quot;
    i = 3
    j = 5
    此时对于字符串 s 和 t 来说,最后两个字符不相等
    由于 &quot;ade&quot; 是 &quot;abde&quot; 的子序列，由 ① 得 dp[3][4] = true
    那么为 t 添加一个不相等的字符之后，&quot;ade&quot; 也是 &quot;abdef&quot; 的子序列，由 ① 得 dp[3][5] = true</code></pre>
<h1 id="s-的前-i-项不是-t-的前-j-1-项的子序列"><a href="#s-的前-i-项不是-t-的前-j-1-项的子序列" class="headerlink" title="**   s 的前 i 项不是 t 的前 j - 1 项的子序列**"></a>**   s 的前 i 项不是 t 的前 j - 1 项的子序列**</h1><pre><code>    s = &quot;ace&quot;
    t = &quot;abdef&quot;
    i = 3
    j = 5
    此时对于字符串 s 和 t 来说,最后两个字符不相等
    由于 &quot;ace&quot; 不是 &quot;abde&quot; 的子序列，由 ① 得 dp[3][4] = false
    那么为 t 添加一个不相等的字符之后 &quot;ade&quot; 也不是 &quot;abdef&quot; 的子序列，由 ① 得 dp[3][5] = false</code></pre>
<p>三、</p>
<hr>
<p>综上所述：</p>
<pre><code>    当最后两个字符相等的时，即 dp[i][j] = dp[i - 1][j - 1]
            当 s 的长度为 i - 1,t 的长度为 j - 1 时
            若 s 为   t 的子序列，则当 s 的长度为 i ,t 的长度为 j 时，s 也为   t 的子序列
            若 s 不为 t 的子序列，则当 s 的长度为 i ,t 的长度为 j 时，s 也不为 t 的子序列
    当最后两个字符串不相等时，即 dp[i][j] = dp[i][j - 1]
            当 s 的长度为 i,t 的长度为 j - 1 时
            若 s 为   t 的子序列，则为 t 则加一个字符之后，s 的长度为 i ,t 的长度为 j 时，s 也为   t 的子序列
            若 s 不为 t 的子序列，则为 t 则加一个字符之后，s 的长度为 i ,t 的长度为 j 时，s 也为   t 的子序列</code></pre>
<hr>
<p>四、<br><img src="https://raw.githubusercontent.com/clay-nuyoah/clay-nuyoah.github.io/master/post-images/2020-11-25/1607932741-roeLGk-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201214155736.png" alt="微信截图_20201214155736.png"></p>
<p>第一步：</p>
<p>初始化：</p>
<pre><code>            将第一行和第一列的数据进行初始化
            第一行表示 t 为空串时，必为 s 的子序列
            第一列表示 s 为空串时，t 必部位 s 的子序列</code></pre>
<p>第二步：</p>
<p>由左到右，由上到下为 dp 数组赋值</p>
<pre><code>            第二行数据：
            dp[1][1] 表示,当 s = &quot;a&quot; t = &quot;a&quot; 时，s 是否为 t 的子序列
            此时两个字符串的最后两个字符相等，所以查看 s=&quot;&quot; t = &quot;&quot; (dp[0][0] 表示)时，s 是否为 t 的子序列
            由于 dp[0][0] = true 所以 s = &quot;a&quot; t = &quot;a&quot; 时 s 为 t 的子序列 即 d[1][1] = true

            dp[1][2] 表示,当 s = &quot;a&quot; t = &quot;ah&quot; 时，s 是否为 t 的子序列
            此时两个字符串的最后两个字符不相等，所以查看 s=&quot;a&quot; t = &quot;a&quot; (dp[1][1] 表示)时，s 是否为 t 的子序列
            由于 dp[0][0] = true s 为 t 的子序列，为 t 添加一个字符之后 s=&quot;a&quot; t = &quot;ah&quot; 此时s 仍为 t 的子序列 即 dp[1][2] = true

            dp[1][3] 表示,当 s = &quot;a&quot; t = &quot;ahb&quot; 时，s 是否为 t 的子序列
            此时两个字符串的最后两个字符不相等，所以查看 s=&quot;a&quot; t = &quot;ah&quot; (dp[1][2] 表示)时，s 是否为 t 的子序列
            由于 dp[1][2] = true s 为 t 的子序列，为 t 添加一个字符之后 s=&quot;a&quot; t = &quot;ahb&quot; 此时s 仍为 t 的子序列 即 dp[1][3] = true

            dp[1][4],dp[1][5],dp[1][6] 同理

            第三行数据：
            dp[2][1] 表示,当 s = &quot;ab&quot; t = &quot;a&quot; 时，s 是否为 t 的子序列
            此时两个字符串的最后两个字符不相等，所以查看 s=&quot;ab&quot; t = &quot;&quot; (dp[2][0] 表示)时，s 是否为 t 的子序列
            由于 dp[2][0] = false s 不为 t 的子序列，为 t 添加一个字符之后 s=&quot;ab&quot; t = &quot;a&quot; 此时s 不为 t 的子序列 即 dp[2][1] = false

            dp[2][2] 表示,当 s = &quot;ab&quot; t = &quot;ah&quot; 时，s 是否为 t 的子序列
            此时两个字符串的最后两个字符不相等，所以查看 s=&quot;ab&quot; t = &quot;a&quot; (dp[2][1] 表示)时，s 是否为 t 的子序列
            由于 dp[2][1] = false s 不为 t 的子序列，为 t 添加一个字符之后 s=&quot;ab&quot; t = &quot;ah&quot; 此时s 不为 t 的子序列 即 dp[2][2] = false

            dp[2][3] 表示 当 s = &quot;ab&quot; t = &quot;ahb&quot; 时，s 是否为 t 的子序列
            此时两个字符串的最后两个字符相等，所以查看 s=&quot;a&quot; t = &quot;ah&quot; (dp[1][2] 表示)时，s 是否为 t 的子序列
            由于 dp[1][2] = true s 为 t 的子序列， 当 s=&quot;ab&quot; t = &quot;ahb&quot; 此时s 为 t 的子序列 即 dp[2][3] = true
            dp[2][4],dp[2][5],dp[2][6] 同理

            第四行也可以用一样的方法进行求解</code></pre>
<p>五、代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public boolean isSubsequence(String s, String t) &#123;</span><br><span class="line">        int sLen &#x3D; s.length(), tLen &#x3D; t.length();</span><br><span class="line">        if (sLen &gt; tLen) return false;</span><br><span class="line">        if (sLen &#x3D;&#x3D; 0) return true;</span><br><span class="line">        boolean[][] dp &#x3D; new boolean[sLen + 1][tLen + 1];</span><br><span class="line">        for (int j &#x3D; 0; j &lt;&#x3D; tLen; j++) &#123;</span><br><span class="line">            dp[0][j] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; sLen; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; tLen; j++) &#123;</span><br><span class="line">                if (s.charAt(i - 1) &#x3D;&#x3D; t.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; dp[i - 1][j - 1];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] &#x3D; dp[i][j - 1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[sLen][tLen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>动态规划</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>使用并查集查找无向图回路</title>
    <url>/2021/01/14/bing-cha-ji/</url>
    <content><![CDATA[<p> 一步步的教你使用并查集查找无向图回路</p>
<a id="more"></a>

<h1 id="一、并查集的操作"><a href="#一、并查集的操作" class="headerlink" title="一、并查集的操作"></a>一、并查集的操作</h1><p>1、查找（find）：确定元素属于哪个集合</p>
<p>2、合并（union）：将两个集合归并成一个集合</p>
<h1 id="二、查找、合并操作代码"><a href="#二、查找、合并操作代码" class="headerlink" title="二、查找、合并操作代码"></a>二、查找、合并操作代码</h1><p><strong>1、查找操作 代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int find(int x, int[] find) &#123;</span><br><span class="line">    if (find[x] &lt; 0)</span><br><span class="line">        return x;</span><br><span class="line">    else</span><br><span class="line">        return find(find[x], find);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、合并操作 代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void union(int root1, int root2, int[] find) &#123;</span><br><span class="line">    find[root1] &#x3D; root2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、-实例讲解"><a href="#三、-实例讲解" class="headerlink" title="三、 实例讲解#"></a>三、 实例讲解#</h1><h2 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h2><p><strong>1、初始化</strong></p>
<pre><code>1、在无向图中存在几个顶点，就开辟一个长度为顶点数量大小的数组， 并初始化为 -1，数组记为 trance</code></pre>
<p><strong>2、find 函数的作用</strong></p>
<p><em>1、</em> 若此时 trance 数组为图示状态，先不用计较该数组是如何得到的，只需要知道 find 函数的执行流程，下边会介绍如何构建 trance 数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/bing-cha-ji/2021/01/21/16-50-45-14cbd3089cc9c8fedbb709741155f999-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210121165039-e52219.png"></p>
<p><em>2、</em>find 函数的执行过程</p>
<p>对 3 调用 find 函数</p>
<pre><code>搜索 trance[3],
由于 trance[3] = 2,
搜索 trance[2],
由于 trance[2] = 1,
搜索 trance[1],
由于 trance[1] = 0,
搜索 trance[0],
由于 trance[0] = -1,
此时返回 0</code></pre>
<p>对 5 调用 find 函数</p>
<pre><code>搜索 trance[5],
由于 trance[5] = 4,
搜索 trance[4],
由于 trance[4] = 1,
此时返回 4</code></pre>
<p>这就是整个 find 的函数的执行流程</p>
<p><strong>2、union 函数的作用</strong></p>
<p>union 函数非常简单，传入两个参数 root1, root2</p>
<pre><code>让第一个参数作为数组 trance 的下标，让第二个参数作为第一个参数对应下标的值
例如 root1 = 3, root2 = 5
则有 trance[3] = 5

例如 例如 root1 = 0, root2 = 2
则 trance[0] = 2</code></pre>
<p><strong>3、如何判断是否存在回路</strong></p>
<p>存在一条边  side，该边有两个顶点 a，b(find 函数的详细过程请看上面 <strong>2、find 函数的作用</strong>)</p>
<p>若</p>
<pre><code>使用 a 调用 find 函数返回 num1 &gt;= 0
使用 b 调用 find 函数返回 num2 &gt;= 0
当 num1 与 num2 相等时，证明若把 side 边纳入到 trance 数组中时，
会出现回路，因此此时不要将 side 边纳入到 trance 数组中</code></pre>
<p><em>示例：</em></p>
<p>此时 trance 数组为图示状态，先不用计较该数组是如何得到的，</p>
<p>只需要知道如何判断回路就可以，下边会介绍如何构建 trance 数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/bing-cha-ji/2021/01/22/18-59-39-0ac970c02df0b3b774112fa1f9afbfde-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210122185914-284af2.png"></p>
<p>存在一条边 side，该边有两个顶点 3，5</p>
<pre><code>使用 2 调用 find 函数 trance[3] = 2
                     trance[2] = 1
                     trance[1] = 0
                     trance[0] = 4
                     trance[4] = -1
                     所以 num1 = 4 &gt;= 0

使用 5 调用 find 函数 trance[5] = 4
                     trance[4] = -1
                     所以 num2 = 4 &gt;= 0
                    由于 num1 = num2,所以在该有无图中存在回路
                    不会将边 side 纳入到 trance 数组中</code></pre>
<h2 id="2、使用并查集判断下图所示的无向图中是否存在回路"><a href="#2、使用并查集判断下图所示的无向图中是否存在回路" class="headerlink" title="2、使用并查集判断下图所示的无向图中是否存在回路"></a>2、使用并查集判断下图所示的无向图中是否存在回路</h2><p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/bing-cha-ji/2021/01/21/16-14-08-973fd7b073b8a90c47a1b0c185c5addf-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210118200641-15e9b8.png"></p>
<p><em>下面将通过实例讲解 trance 数组是如何构建的</em></p>
<p><strong>1、初始化</strong></p>
<p>由于在图示中存在 4 个顶点，所以初始化一个长度为 4 的数组，数组记为 trance，</p>
<p>并初始化为 -1</p>
<p>数组的初始状态如图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/bing-cha-ji/2021/01/22/19-20-23-f763a0d4ed8b88879304c1a2656221b2-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210122192012_1-0cd5df.png"></p>
<p><strong>2、将边 a 纳入到 trance 数组</strong></p>
<p>此时数组 trance 的状态如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/bing-cha-ji/2021/01/22/19-20-23-f763a0d4ed8b88879304c1a2656221b2-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210122192012_1-0cd5df.png"></p>
<pre><code>边 a 有 0， 1 顶点
对 0 调用 find 函数    tranc[0] = -1
                    所以 num1 = 0 &gt;= 0

对 1 调用 find 函数    tranc[1] = -1
                    所以 num2 = 1 &gt;= 0

此时使用 num1 和 num2 调用 union 函数 (这里可以看 2、union 函数的作用 上方黑体字部分)
                    有 trance[0] = 1</code></pre>
<p><strong>2、将边 b 纳入到 trance 数组</strong></p>
<p>此时数组 trance 的状态如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/bing-cha-ji/2021/01/22/19-25-48-8bead02351c0bcceb3d024ee7d908a71-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210122192540_2-718ed1.png"></p>
<pre><code>边 b 有 0， 2 顶点
对 0 调用 find 函数    tranc[0] = 1
                    tranc[1] = -1
                    所以 num1 = 1 &gt;= 0

对 2 调用 find 函数 tranc[2] = -1
                    所以 num2 = 2 &gt;= 0

此时使用 num1 和 num2 调用 union 函数
                    有 trance[1] = 2</code></pre>
<p><strong>3、将边 c 纳入到 trance 数组</strong></p>
<p>此时数组 trance 的状态如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/bing-cha-ji/2021/01/22/19-44-24-f50b59405fefcfe8783fc42be5a83c21-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210122193619_3-d5651c.png"></p>
<pre><code>边 c 有 0， 3 顶点
对 0 调用 find 函数    tranc[0] = 1
                    tranc[1] = 2
                    trance[2] = -1
                    所以 num1 = 2 &gt;= 0

对 3 调用 find 函数 tranc[3] = -1
                    所以 num2 = 3 &gt;= 0

此时使用 num1 和 num2 调用 union 函数
                    有 trance[2] = 3</code></pre>
<p><strong>4、将边 d 纳入到 trance 数组</strong></p>
<p>此时数组 trance 的状态如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/bing-cha-ji/2021/01/22/19-49-25-7bfd5acf78cff097307e28014a4e08da-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210122194910_4-be3740.png"></p>
<pre><code>边 d 有 1， 2 顶点
对 1 调用 find 函数    tranc[1] = 2
                    tranc[2] = 3
                    trance[3] = -1
                    所以 num1 = 3 &gt;= 0

对 2 调用 find 函数    tranc[2] = 3
                    tranc[3] = -1
                    所以 num2 = 3 &gt;= 0

此时 num1 = num2 存在回路，就不向 trance 中纳入边 d，此时 trance 数组不发生变化</code></pre>
<p><strong>5、将边 e 纳入到 trance 数组</strong></p>
<p>此时数组 trance 的状态如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/bing-cha-ji/2021/01/22/19-49-25-7bfd5acf78cff097307e28014a4e08da-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210122194910_4-be3740.png"></p>
<pre><code>边 e 有 1， 3 顶点
对 1 调用 find 函数    tranc[1] = 2
                    tranc[2] = 3
                    trance[3] = -1
                    所以 num1 = 3 &gt;= 0

对 3 调用 find 函数    tranc[3] = -1
                    所以 num2 = 3 &gt;= 0

此时 num1 = num2 存在回路，就不向 trance 中纳入边 e，此时 trance 数组不发生变化</code></pre>
<p><strong>6、将边 f 纳入到 trance 数组</strong></p>
<p>此时数组 trance 的状态如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/bing-cha-ji/2021/01/22/19-49-25-7bfd5acf78cff097307e28014a4e08da-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210122194910_4-be3740.png"></p>
<pre><code>边 f 有 2， 3 顶点
对 2 调用 find 函数    tranc[2] = 3
                    trance[3] = -1
                    所以 num1 = 3 &gt;= 0

对 3 调用 find 函数    tranc[3] = -1
                    所以 num2 = 3 &gt;= 0

此时 num1 = num2 存在回路，就不向 trance 中纳入边 e，此时 trance 数组不发生变化</code></pre>
<p>四、完整代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package other;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 并查集</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UnionFindSet &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UnionFindSet unionFindSet &#x3D; new UnionFindSet();</span><br><span class="line">        int[] trance &#x3D; new int[4];</span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;0-1&quot;);</span><br><span class="line">        list.add(&quot;0-2&quot;);</span><br><span class="line">        list.add(&quot;0-3&quot;);</span><br><span class="line">        list.add(&quot;1-2&quot;);</span><br><span class="line">        list.add(&quot;1-3&quot;);</span><br><span class="line">        list.add(&quot;2-3&quot;);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; trance.length; i++) &#123;</span><br><span class="line">            trance[i] &#x3D; -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (String s : list) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(trance));</span><br><span class="line">            String[] split &#x3D; s.split(&quot;-&quot;);</span><br><span class="line">            int find1 &#x3D; unionFindSet.find(Integer.parseInt(split[0]), trance);</span><br><span class="line">            int find2 &#x3D; unionFindSet.find(Integer.parseInt(split[1]), trance);</span><br><span class="line">            if (find1 !&#x3D; find2) &#123;</span><br><span class="line">                unionFindSet.union(find1, find2, trance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int find(int x, int[] trance) &#123;</span><br><span class="line">        if (trance[x] &lt; 0)</span><br><span class="line">            return x;</span><br><span class="line">        else</span><br><span class="line">            return find(trance[x], trance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void union(int root1, int root2, int[] trance) &#123;</span><br><span class="line">        trance[root1] &#x3D; root2;&#x2F;&#x2F;将root1作为root2的新树根</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>并查集</tag>
        <tag>查找无向图回路</tag>
      </tags>
  </entry>
  <entry>
    <title>连续子数组的最大和</title>
    <url>/2018/12/12/lian-xu-zi-shu-zu-de-zui-da-he/</url>
    <content><![CDATA[<p>leetcode 题库 43 最大子序和</p>
<a id="more"></a>

<p>题目描述：</p>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），</p>
<p>返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4]</p>
<p>输出: 6</p>
<p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>来源：力扣（LeetCode）</p>
<p>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray">https://leetcode-cn.com/problems/maximum-subarray</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">       int sum &#x3D; 0;</span><br><span class="line">       int max &#x3D; Integer.MIN_VALUE;</span><br><span class="line">       for (int num : nums) &#123;</span><br><span class="line">           sum +&#x3D; num;</span><br><span class="line">           if (max &lt; sum) &#123;</span><br><span class="line">               max &#x3D; sum;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (sum &lt; 0) &#123;</span><br><span class="line">               sum &#x3D; 0;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>每一次相加的时候，只要是 sum 的值大于零，就相加的数来说就是把相加的数增大，</p>
<p>而相加的数是不知道的，结果也不知道，所以有可能取到最大值。</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>多数元素 leetcode</title>
    <url>/2021/01/10/duo-shu-yuan-su-leetcode/</url>
    <content><![CDATA[<p>leetcode 题库 剑指 Offer 39 数组中出现次数超过一半的数字</p>
<p>使用 摩尔投票法 解决众数问题</p>
<a id="more"></a>

<h1 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例 1:</p>
<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</p>
<p>输出: 2</p>
<p>来源：力扣（LeetCode）</p>
<p>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof</a></p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>可以换做下面的方式来理解本体：</p>
<h1 id="二、诸侯争霸游戏："><a href="#二、诸侯争霸游戏：" class="headerlink" title="二、诸侯争霸游戏："></a>二、诸侯争霸游戏：</h1><p><strong>游戏规则设定：</strong></p>
<pre><code>1、m 个国家进行诸侯争霸；

2、每个国家的士兵人数为 a1,a2……，am,总士兵人数为 a1 + a2 + a3 …… + am 记为 C；

3、其中存在一个国家 i 的士兵人数超过总士兵人数的一半，即 ai &gt; C/2；

4、m 个国家随机的往战场上面投放士兵，并且每个国家每次只能投放一个士兵；

5、只要战场上存在两个不同国家的士兵，那么就会相会搏杀，两个士兵同归于尽；

6、所有的国家都要出动所有的士兵参战，中途不能退出，直至士兵消耗完毕；

7、最后的胜利者属于最后能够生存下来的国家；

则最终的胜利一定属于第 i 个国家，这个国家就是那个士兵数量超过总士兵人数的一半的国家；</code></pre>
<h1 id="三、代码如下："><a href="#三、代码如下：" class="headerlink" title="三、代码如下："></a>三、代码如下：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int majorityElement(int[] nums) &#123;</span><br><span class="line">    int mode &#x3D; 0;&#x2F;&#x2F;士兵数量暂时领先的国家</span><br><span class="line">    int count &#x3D; 0;&#x2F;&#x2F;士兵数量暂时领先的数量</span><br><span class="line">    for (int num : nums) &#123;      &#x2F;&#x2F;每个国家都随机的往战场中投放士兵</span><br><span class="line">        if (count &#x3D;&#x3D; 0) &#123;       &#x2F;&#x2F;若战场中不存在士兵</span><br><span class="line">            mode &#x3D; num;         &#x2F;&#x2F;投放士兵的国家就变成了  士兵数量暂时领先的国家</span><br><span class="line">        &#125;</span><br><span class="line">        if (mode &#x3D;&#x3D; num) &#123;      &#x2F;&#x2F;如果投放的士兵和战场中的士兵来自相同的国家</span><br><span class="line">            count++;            &#x2F;&#x2F;士兵数量就会 + 1</span><br><span class="line">        &#125; else &#123;                &#x2F;&#x2F;如果投放的士兵和战场中的士兵来自不同的国家</span><br><span class="line">            count--;            &#x2F;&#x2F;两个士兵同归于尽 这是会消耗掉 1 个 暂时领先的国家的士兵</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;最后可以生存下来的国家</span><br><span class="line">    return mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>摩尔投票法</tag>
        <tag>众数</tag>
      </tags>
  </entry>
  <entry>
    <title>玩筹码 leetcode</title>
    <url>/2020/11/30/wan-chou-ma-leetcode/</url>
    <content><![CDATA[<p>leetcode 题库 1217 玩筹码</p>
<a id="more"></a>

<h1 id="一、题目描述："><a href="#一、题目描述：" class="headerlink" title="一、题目描述："></a>一、题目描述：</h1><p>数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。</p>
<p>你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：</p>
<p>将第 i 个筹码向左或者右移动 2 个单位，代价为 0。</p>
<p>将第 i 个筹码向左或者右移动 1 个单位，代价为 1。</p>
<p>最开始的时候，同一位置上也可能放着两个或者更多的筹码。</p>
<p>返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。</p>
<p>示例 1：</p>
<p>输入：chips = [1,2,3]</p>
<p>输出：1</p>
<p>解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。</p>
<p>示例 2：</p>
<p>输入：chips = [2,2,2,3,3]</p>
<p>输出：2</p>
<p>解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。</p>
<p>来源：力扣（LeetCode）</p>
<p>链接：<a href="https://leetcode-cn.com/problems/minimum-cost-to-move-chips-to-the-same-position">https://leetcode-cn.com/problems/minimum-cost-to-move-chips-to-the-same-position</a></p>
<h1 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h1><p>我们任意挑选两个相邻的位置，两个位置必然会有一个偶数位置(记为 a)，</p>
<p>一个奇数位置(记为b),由于移动偶数个位置的代价为 0，</p>
<p>所以把所有在偶数位置的筹码移动到 a 点的代价和为 0</p>
<p>(每一个筹码都可以通过移动偶数个单位移动到 a 点),</p>
<p>同样把所有在奇数位置的筹码移动到 b 点的代价和也为 0,</p>
<p>这时所有的筹码都集中到了 a b 两点，</p>
<p>那么将 筹码最少的点的所有筹码 移动到 筹码最多的点 的代价就是所求的最小代价</p>
<p>算法实现是直接求偶数位置的个数和奇数位置的个数，然后返回个数少的数目就行了</p>
<h1 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public int minCostToMoveChips(int[] positions) &#123;</span><br><span class="line">	        int eventCount &#x3D; 0;</span><br><span class="line">	        int addCount &#x3D; 0;</span><br><span class="line">	        for (int position : positions) &#123;</span><br><span class="line">	            if (position % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">	                eventCount++;</span><br><span class="line">	            &#125; else &#123;</span><br><span class="line">	                addCount++;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        return Math.min(eventCount, addCount);</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>最后一块石头的重量 leetcode</title>
    <url>/2021/01/11/zui-hou-yi-kuai-shi-tou-de-zhong-liang/</url>
    <content><![CDATA[<p>leetcode 题库 1046 最后一块石头的重量</p>
<p>使用了二分查找和插入排序的方法</p>
<a id="more"></a>

<h1 id="一、题目描述："><a href="#一、题目描述：" class="headerlink" title="一、题目描述："></a>一、题目描述：</h1><p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。</p>
<p>假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p>
<p>如果 x == y，那么两块石头都会被完全粉碎；</p>
<p>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</p>
<p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。</p>
<p>来源：力扣（LeetCode）</p>
<p>链接：<a href="https://leetcode-cn.com/problems/last-stone-weight">https://leetcode-cn.com/problems/last-stone-weight</a></p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h1><p><strong>一、初始化</strong></p>
<pre><code>对数组中的元素进行排序;

这样做有以下两个好处：

1、能从数组的末尾取出最重的两块石头

2、取出两块最重的石头之后，剩余的石头仍然保持有序，

可以使用 二分查找 找到 新石头 在数组中插入的位置。</code></pre>
<p>关于如何进行二分查找，这里有篇非常好的讲解，对二分查找，寻找左侧边界的二分查找，</p>
<p>寻找右侧边界的二分查找都做了详细的介绍</p>
<p>地址：<a href="https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/">https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/</a></p>
<p><strong>二、当两块最重的石头重量相同时</strong></p>
<p>设保存石头重量的数组名称为 stones    </p>
<pre><code>1、将两块石头同时粉碎，但是并不会产生新的石头

2、创建新数组 newStones 用来保存新的数据(新数组的长度为 stones.length - 2)

3、将 stones 前 stones.length - 2 的数据依次复制到新数组 newStones 中</code></pre>
<p><strong>三、当两块石头单位重量不同时</strong></p>
<pre><code>1、在数组 stones 取出两块最重的石头

2、将两块石头粉碎，并形成新的石头 newStone

3、使用新石头 newStone 在数组 Stones 中查找新石头需要插入的的位置 i

（查找插入位置时需要排除掉最后的两块石头，即返回 i 的范围为 0 &lt;= i &lt; stones.length - 2）

4、创建新数组 newStones 用来保存新的数据(新数组的长度为 stones.length - 1)

5、将数组 stones i 之前的数据依次插入到 newStones 数组 i 之前的位置

5、将 newStone 插入到 newStones 的 i 位置

6、将 stones i 位置和 i 之后的数据插入依次插入到 newStones i 之后的位置</code></pre>
<p><strong>四、结果返回</strong></p>
<p><em>当数组的长度为 0 或者是为 1 时返回结果</em></p>
<pre><code>当数组长度为 0 时返回 0

当数组的长度为 1 时，返回数组中的第一个元素</code></pre>
<h1 id="三、代码如下"><a href="#三、代码如下" class="headerlink" title="三、代码如下"></a>三、代码如下</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int lastStoneWeight(int[] stones) &#123;</span><br><span class="line">       &#x2F;&#x2F;用来保存新的数据</span><br><span class="line">       int[] newStones &#x3D; stones;</span><br><span class="line">       Arrays.sort(newStones);</span><br><span class="line">       for (; newStones.length &gt; 1; ) &#123;</span><br><span class="line">           int max_1 &#x3D; newStones[newStones.length - 1];</span><br><span class="line">           int max_2 &#x3D; newStones[newStones.length - 2];</span><br><span class="line">           int t &#x3D; max_1 - max_2;</span><br><span class="line">           int[] original &#x3D; newStones;</span><br><span class="line">           if (t &#x3D;&#x3D; 0) &#123;</span><br><span class="line">               &#x2F;&#x2F;每次都会创建一个新数组</span><br><span class="line">               newStones &#x3D; new int[newStones.length - 2];</span><br><span class="line">               &#x2F;&#x2F;将 stones 前 stones.length - 2 的数据依次复制到新数组 newStones 中</span><br><span class="line">               copyArray(original, 0, newStones, 0, newStones.length);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F;每次都会创建一个新数组</span><br><span class="line">               newStones &#x3D; new int[newStones.length - 1];</span><br><span class="line">			&#x2F;&#x2F;排除掉最后的两块石头</span><br><span class="line">               int index &#x3D; leftBoundBinarySearch(original, t, 0, original.length - 2);</span><br><span class="line">               &#x2F;&#x2F;original 0 ~ index - 1   arr 0 ~ index - 1</span><br><span class="line">               &#x2F;&#x2F;将数组 stones i 之前的数据依次插入到 newStones 数组 i 之前的位置</span><br><span class="line">               copyArray(original, 0, newStones, 0, index);</span><br><span class="line">               &#x2F;&#x2F;arr index</span><br><span class="line">               &#x2F;&#x2F;将 newStone 插入到 newStones 的 i 位置</span><br><span class="line">               newStones[index] &#x3D; t;</span><br><span class="line">               &#x2F;&#x2F;将 stones i 之后的数据插入依次插入到 newStones i 之后的位置</span><br><span class="line">               copyArray(original, index, newStones, index + 1, newStones.length - index - 1);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return newStones.length &#x3D;&#x3D; 0 ? 0 : newStones[0];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * @param originalArr   数据来源的数组</span><br><span class="line">    * @param originalIndex 从数据来源的那个下标开始取值</span><br><span class="line">    * @param targetArr     复制的目标数组</span><br><span class="line">    * @param targetIndex   从目标数组的哪个下标开始赋值</span><br><span class="line">    * @param len           需要赋值的长度</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private void copyArray(int[] originalArr, int originalIndex, int[] targetArr, int targetIndex, int len) &#123;</span><br><span class="line">       for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">           targetArr[targetIndex + i] &#x3D; originalArr[originalIndex + i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 寻找左侧边界的二分搜索</span><br><span class="line">    *</span><br><span class="line">    * @param nums</span><br><span class="line">    * @param target</span><br><span class="line">    * @return</span><br><span class="line">    *&#x2F;</span><br><span class="line">   int leftBoundBinarySearch(int[] nums, int target, int l, int r) &#123;</span><br><span class="line">       if (nums.length &#x3D;&#x3D; 0) return -1;</span><br><span class="line">       int left &#x3D; l;</span><br><span class="line">       int right &#x3D; r; &#x2F;&#x2F; 注意</span><br><span class="line"></span><br><span class="line">       while (left &lt; right) &#123; &#x2F;&#x2F; 注意</span><br><span class="line">           int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">           if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">               right &#x3D; mid;</span><br><span class="line">           &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">               left &#x3D; mid + 1;</span><br><span class="line">           &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">               right &#x3D; mid; &#x2F;&#x2F; 注意</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return left;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title>TSP旅行推销员问题</title>
    <url>/2020/11/25/tsp-lu-xing-tui-xiao-yuan-wen-ti/</url>
    <content><![CDATA[<p>使用动态规划的方式求解TSP旅行推销员问题</p>
<a id="more"></a>
<h1 id="一、问题描述："><a href="#一、问题描述：" class="headerlink" title="一、问题描述："></a>一、问题描述：</h1><p>给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。</p>
<h1 id="二、例题"><a href="#二、例题" class="headerlink" title="二、例题"></a>二、例题</h1><p><img src="https://clay-nuyoah.github.io/post-images/2020-11-25/o_image_2.png"></p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;图 1    </p>
<p><img src="https://clay-nuyoah.github.io/post-images/2020-11-25/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201125211440.png"><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;图 2</p>
<p>有向图图1可以用图2的矩阵进行表示。</p>
<p>现在要求从城市 0 出发，访问城市 1，城市 2，城市 3 （需要访遍每一座城市），</p>
<p>最后回到城市 0 的最短路径</p>
<h1 id="三、基础知识讲解"><a href="#三、基础知识讲解" class="headerlink" title="三、基础知识讲解"></a>三、基础知识讲解</h1><h2 id="1、首先定义一项规则"><a href="#1、首先定义一项规则" class="headerlink" title="1、首先定义一项规则"></a>1、首先定义一项规则</h2><p>i -&gt; V’ -&gt; 0 = num    ①</p>
<p>可以记为 d(i,V’) = num ②</p>
<p>其中 V’ = {i1, i2, …, ik} k = 1,2,3,…,n 表示需要经过的点集</p>
<p> ① 表示，从点 i 出发，经果点集 V’，最后到达起始点 0 的最短路径为 num </p>
<p> ②是简洁的表示形式</p>
<p>如 3 -&gt; {2, 3} -&gt; 0    10</p>
<p>所代表的意思是，从点 3 出发，经过点 2，点3 最后到达起始点 0 的最短路径为 10</p>
<p>也可以表示为 d(3,{2,3}) = 10</p>
<h1 id="四、例题分析"><a href="#四、例题分析" class="headerlink" title="四、例题分析"></a>四、例题分析</h1><p><strong>1、该题需要进行逆过程思考, 接下来将会对下列的过程进行讨论：</strong></p>
<pre><code>**1、不经过任何点集**

    1 -&gt; &#123;&#125; -&gt; 0    记为 d(1,&#123;&#125;)    (4.1.1)
    2 -&gt; &#123;&#125; -&gt; 0    记为 d(2,&#123;&#125;)    (4.1.2)
    3 -&gt; &#123;&#125; -&gt; 0    记为 d(3,&#123;&#125;)    (4.1.3)

**2、经过 1 条点集**

    2 -&gt; &#123;1&#125; -&gt; 0    记为 d(2,&#123;1&#125;)    (4.1.4)
    3 -&gt; &#123;1&#125; -&gt; 0    记为 d(3,&#123;1&#125;)    (4.1.5)

    1 -&gt; &#123;2&#125; -&gt; 0    记为 d(1,&#123;2&#125;)    (4.1.6)
    3 -&gt; &#123;2&#125; -&gt; 0    记为 d(3,&#123;2&#125;)    (4.1.7)

    1 -&gt; &#123;3&#125; -&gt; 0    记为 d(1,&#123;3&#125;)    (4.1.8)
    2 -&gt; &#123;3&#125; -&gt; 0    记为 d(2,&#123;3&#125;)    (4.1.9)

**3、经过 2 条点集**

    1 -&gt; &#123;2, 3&#125; -&gt; 0    记为 d(1,&#123;2, 3&#125;)    (4.1.10)
    2 -&gt; &#123;1, 3&#125; -&gt; 0    记为 d(2,&#123;1, 3&#125;)    (4.1.11)
    3 -&gt; &#123;1, 2&#125; -&gt; 0    记为 d(3,&#123;1, 2&#125;)    (4.1.12)

**4、经过 3 条点集**

    0 -&gt; &#123;1, 2, 3&#125; -&gt; 0    (4.1.13) d(0,&#123;1, 2, 3&#125;) (4.1.13)</code></pre>
<p><strong>2、对 1 内容进行解释</strong></p>
<pre><code>由于最终要回到起点 0 点，在我们不经过任何点集时，有 1 点，2 点，3 点，可以回到 0 点，

所以有如下解释

(4.1.1) 表示，从 1 点不经过任何点集，到达起始点 0 点；
(4.1.2) 表示，从 2 点不经过任何点集，到达起始点 0 点；
(4.1.3) 表示，从 3 点不经过任何点集，到达起始点 0 点；

(4.1.4) 表示，从 2 点经过点集 1，到达起始点 0 点；
(4.1.5) 表示，从 3 点经过点集 1，到达起始点 0 点；

(4.1.6) 表示，从 1 点经过点集 2，到达起始点 0 点；
(4.1.7) 表示，从 3 点经过点集 2，到达起始点 0 点；

(4.1.8) 表示，从 1 点经过点集 3，到达起始点 0 点；
(4.1.9) 表示，从 2 点经过点集 3，到达起始点 0 点；

(4.1.10) 表示，从 1 点经过点集 2，3，到达起始点 0 点；
(4.1.11) 表示，从 2 点经过点集 1，3，到达起始点 0 点；
(4.1.12) 表示，从 3 点经过点集 1，2，到达起始点 0 点；

(4.1.13) 表示，从起始 0 点经过点集1， 2，3，到达起始点 0 点；</code></pre>
<p>显然 (4.1.13) 是我们需要求解的结果,</p>
<p>现在还不适合求解最短路径，因此没有给出任何 ① 中提到的 num 的信息</p>
<p><strong>3、对(4.1.x)的数据进行分解</strong></p>
<pre><code>**1、不经过任何点集**

    1 -&gt; &#123;&#125; -&gt; 0    (4.1.1)
    2 -&gt; &#123;&#125; -&gt; 0    (4.1.2)
    3 -&gt; &#123;&#125; -&gt; 0    (4.1.3)

**2、经过 1 条点集**

    2 -&gt; &#123;1&#125; -&gt; 0    (4.1.4)
        2 -&gt; 1 -&gt; &#123;&#125; -&gt; 0    (4.1.4.1)
    3 -&gt; &#123;1&#125; -&gt; 0    (4.1.5)
        3 -&gt; 1 -&gt; &#123;&#125; -&gt; 0    (4.1.5.1)

    1 -&gt; &#123;2&#125; -&gt; 0    (4.1.6)
        1 -&gt; 2 -&gt; &#123;&#125; -&gt; 0    (4.1.6.1)
    3 -&gt; &#123;2&#125; -&gt; 0    (4.1.7)
        3 -&gt; 2 -&gt; &#123;&#125; -&gt; 0    (4.1.7.1)

    1 -&gt; &#123;3&#125; -&gt; 0    (4.1.8)
        1 -&gt; 3 -&gt; &#123;&#125; -&gt; 0    (4.1.8.1)
    2 -&gt; &#123;3&#125; -&gt; 0    (4.1.9)
        2 -&gt; 3 -&gt; &#123;&#125; -&gt; 0    (4.1.9.1)

**3、经过 2 条点集**

    1 -&gt; &#123;2, 3&#125; -&gt; 0    (4.1.10)
        1 -&gt; 2 -&gt; &#123;3&#125; -&gt; 0    (4.1.10.1)
        1 -&gt; 3 -&gt; &#123;2&#125; -&gt; 0     (4.1.10.2)

    2 -&gt; &#123;1, 3&#125; -&gt; 0    (4.1.11)
        2 -&gt; 1 -&gt; &#123;3&#125; -&gt; 0    (4.1.11.1)
        2 -&gt; 3 -&gt; &#123;1&#125; -&gt; 0    (4.1.11.2)

    3 -&gt; &#123;1, 2&#125; -&gt; 0    (4.1.12)
        3 -&gt; 1 -&gt; &#123;2&#125; -&gt; 0    (4.1.12.1)
        3 -&gt; 2 -&gt; &#123;1&#125; -&gt; 0    (4.1.12.2)

**4、经过 3 条点集**

    0 -&gt; &#123;1, 2, 3&#125; -&gt; 0    (4.1.13)
        0 -&gt; 1 -&gt; &#123;2,3&#125; -&gt; 0    (4.1.13.1)
        0 -&gt; 2 -&gt; &#123;1,3&#125; -&gt; 0    (4.1.13.2)
        0 -&gt; 3 -&gt; &#123;1,2&#125; -&gt; 0    (4.1.13.3)</code></pre>
<p><strong>4、数据分解带来的好处</strong></p>
<p>为什么要对上述数据进行分解呢，因为分解之后我们就可以利用上面已经产生的数据，简化计算。</p>
<p>有了 3 的分解过程，我们就可以求最短路径了，</p>
<p>由图 2 可知，C 表示各个点的路径长度，即 C[i][j] 表示从 i 点到达 j 点的路径长度。</p>
<p>由 ② 可知，d(i,V’) 表示，从点 i 出发，经过点集 V’ 到达零的最短路径</p>
<p>现在对上述的分解过程进行第一部分讲解,<br>    第一部<br>        <strong>1、不经过任何点集</strong></p>
<pre><code>    1 -&gt; &#123;&#125; -&gt; 0    (4.1.1)
    2 -&gt; &#123;&#125; -&gt; 0    (4.1.2)
    3 -&gt; &#123;&#125; -&gt; 0    (4.1.3)</code></pre>
<p>对于这三项不用计算，直接求最短路径</p>
<pre><code>(4.1.1) 表示，从 1 点不经过任何点集，到达起始点 0 点，即 1 到 0 点的距离，可以用矩阵
C[1][0] = 5
(4.1.2) 表示，从 2 点不经过任何点集，到达起始点 0 点,即 2 到 0 点的距离，可以用矩阵
C[2][0] = 6
(4.1.3) 表示，从 3 点不经过任何点集，到达起始点 0 点，即 3 到 0 点的距离，可以用矩阵
C[2][0] = 3</code></pre>
<p>整理得，</p>
<pre><code>**1、不经过任何点集**

1 -&gt; &#123;&#125; -&gt; 0    记为 d(1,&#123;&#125;) = 5        (4.4.1)
2 -&gt; &#123;&#125; -&gt; 0    记为 d(2,&#123;&#125;) = 6        (4.4.2)
3 -&gt; &#123;&#125; -&gt; 0    记为 d(3,&#123;&#125;) = 3        (4.4.3)</code></pre>
<p>进行第二部分的讲解</p>
<pre><code>第二部分
    **2、经过 1 条点集**

        2 -&gt; &#123;1&#125; -&gt; 0    (4.1.4)
            2 -&gt; 1 -&gt; &#123;&#125; -&gt; 0    (4.1.4.1)
        3 -&gt; &#123;1&#125; -&gt; 0    (4.1.5)
            3 -&gt; 1 -&gt; &#123;&#125; -&gt; 0    (4.1.5.1)

        1 -&gt; &#123;2&#125; -&gt; 0    (4.1.6)
            1 -&gt; 2 -&gt; &#123;&#125; -&gt; 0    (4.1.6.1)
        3 -&gt; &#123;2&#125; -&gt; 0    (4.1.7)
            3 -&gt; 2 -&gt; &#123;&#125; -&gt; 0    (4.1.7.1)

        1 -&gt; &#123;3&#125; -&gt; 0    (4.1.8)
            1 -&gt; 3 -&gt; &#123;&#125; -&gt; 0    (4.1.8.1)
        2 -&gt; &#123;3&#125; -&gt; 0    (4.1.9)
            2 -&gt; 3 -&gt; &#123;&#125; -&gt; 0    (4.1.9.1)</code></pre>
<p>对于 (4.1.4.1) 可以看成两部分，第一部分时 2 -&gt; 1，第二部分是 1 -&gt; {} -&gt; 0，</p>
<p>即先从点 2 出发然后经过点 1，然后经过空点集，到达 0 点</p>
<p>第一部分为矩阵 C[2][1] = 4 的值</p>
<p>而第二部分也已经求解，即 (4.4.1) 的结果 d(1,{}) = 5</p>
<p>所以 2 -&gt; {1} -&gt; 0 =&gt; 2 -&gt; 1 -&gt; {} -&gt; 0 =&gt; C[2][1] + d(1,{}) = 4 + 5 = 9</p>
<p>对于 (4.1.5.1) 可以看成两部分，第一部分时 3 -&gt; 1，第二部分是 1 -&gt; {} -&gt; 0，</p>
<p>即先从点 3 出发然后经过点 1，然后经过空点集，到达 0 点</p>
<p>第一部分为矩阵 C[3][1] = 7 的值</p>
<p>可以发现第二部分已经求解，即 (4.4.1) 的结果 d(1,{}) = 5</p>
<p>所以 3 -&gt; {1} -&gt; 0 =&gt; 3 -&gt; 1 -&gt; {} -&gt; 0 =&gt; C[3][1] + d(1,{}) = 7 + 5 = 12</p>
<p>同理，可得其他;</p>
<p>整理得，</p>
<pre><code>(4.1.4.1) : C[2][1] + d(1,&#123;&#125;) = 4 + 5 = 9    记为 d(2,&#123;1&#125;) = 9    (4.4.4)
(4.1.5.1) : C[3][1] + d(1,&#123;&#125;) = 7 + 5 = 12    记为 d(3,&#123;1&#125;) = 12    (4.4.5)
(4.1.6.1) : C[1][2] + d(2,&#123;&#125;) = 2 + 6 = 8    记为 d(1,&#123;2&#125;) = 8    (4.4.6)
(4.1.7.1) : C[3][2] + d(2,&#123;&#125;) = 5 + 6 = 11    记为 d(3,&#123;2&#125;) = 11    (4.4.7)
(4.1.8.1) : C[1][3] + d(3,&#123;&#125;) = 3 + 3 = 6    记为 d(1,&#123;3&#125;) = 6    (4.4.8)
(4.1.9.1) : C[2][3] + d(3,&#123;&#125;) = 2 + 3 = 5    记为 d(2,&#123;3&#125;) = 5    (4.4.9)</code></pre>
<p>进行第三部分得讲解</p>
<pre><code>第三部分
    **3、经过 2 条点集**

        1 -&gt; &#123;2, 3&#125; -&gt; 0    (4.1.10)
            1 -&gt; 2 -&gt; &#123;3&#125; -&gt; 0    (4.1.10.1)
            1 -&gt; 3 -&gt; &#123;2&#125; -&gt; 0     (4.1.10.2)

        2 -&gt; &#123;1, 3&#125; -&gt; 0    (4.1.11)
            2 -&gt; 1 -&gt; &#123;3&#125; -&gt; 0    (4.1.11.1)
            2 -&gt; 3 -&gt; &#123;1&#125; -&gt; 0    (4.1.11.2)

        3 -&gt; &#123;1, 2&#125; -&gt; 0    (4.1.12)
            3 -&gt; 1 -&gt; &#123;2&#125; -&gt; 0    (4.1.12.1)
            3 -&gt; 2 -&gt; &#123;1&#125; -&gt; 0    (4.1.12.2)</code></pre>
<p>1 -&gt; {2, 3} -&gt; 0 ，表示从 点 1 出发，经过点集 2 3，然后达到 0，得最短路径</p>
<p>此时我们有两种方式可以实现该过程，即上式得 (4.1.10.1) 和 (4.1.10.2)</p>
<p>(4.1.10.1) 表示先从点 1 出发，到达点 2，然后经过点集 3，最后到达起始点 0</p>
<p>(4.1.10.2) 表示先从点 1 出发，到达点 3，然后经过点集 2，最后到达起始点 0</p>
<p>因为要实现 1 -&gt; {2, 3} -&gt; 0 这个过程，有两种方式，而我们要求的是最短路径，</p>
<p>所以要求得 1 -&gt; {2, 3} -&gt; 0 最短路径为 1 -&gt; 2 -&gt; {3} -&gt; 0 和 1 -&gt; 3 -&gt; {2} -&gt; 0 得最小值</p>
<p>对于 (4.1.10.1) 可以分解为两个过程，第一个过程为 1 -&gt; 2，第二个过程为 2 -&gt; {3} -&gt; 0</p>
<p>即先从点 1 出发，经过点 2，在经过点集 3，最后到达起始点 0</p>
<p>第一部分为矩阵 C[1][2] = 2 的值</p>
<p>而第二部分也已经求解，即 (4.4.9) 的结果 d(2,{3}) = 5</p>
<p>所以 1 -&gt; 2 -&gt; {3} -&gt; 0 = C[1][2] + d(2,{3}) = 2 + 5 = 7 </p>
<p>对于 (4.1.10.1) 可以分解为两个过程，第一个过程为 1 -&gt; 3，第二个过程为 3 -&gt; {2} -&gt; 0</p>
<p>即先从点 1 出发，经过点 2，在经过点集 3，最后到达起始点 0</p>
<p>第一部分为矩阵 C[1][3] = 3 的值</p>
<p>而第二部分也已经求解，即 (4.4.7) 的结果 d(3,{2}) = 11</p>
<p>所以 1 -&gt; 3 -&gt; {2} -&gt; 0     = C[1][3] + d(3,{2}) = 3 + 11 = 14</p>
<p>所以 1 -&gt; {2, 3} -&gt; 0 需要取两者得最小值为 min(7, 14) = 7</p>
<p>同理，可得其他;</p>
<p>整理得，</p>
<pre><code>(4.1.10.1) : C[1][2] + d(2,&#123;3&#125;) = 2 + 5 = 7    
(4.1.10.2) : C[1][3] + d(3,&#123;2&#125;) = 3 + 11 = 14
(4.1.11.1) : C[2][1] + d(1,&#123;3&#125;) = 4 + 6 = 10
(4.1.11.2) : C[2][3] + d(3,&#123;1&#125;) = 2 + 12 = 14
(4.1.12.1) : C[3][1] + d(1,&#123;2&#125;) = 7 + 8 = 15
(4.1.12.2) : C[3][2] + d(2,&#123;1&#125;) = 5 + 9 = 14
取最小值得
(4.1.10) : min((4.1.10.1),(4.1.10.2)) = 7         记为 d(1,&#123;2,3&#125;) = 7        (4.4.10)
(4.1.11) : min((4.1.11.1),(4.1.11.2)) = 10        记为 d(2,&#123;1,3&#125;) = 10        (4.4.11)
(4.1.12) : min((4.1.12.1),(4.1.12.2)) = 14        记为 d(3,&#123;1,2&#125;) = 14        (4.4.12)</code></pre>
<p>进行第四部分的讲解</p>
<pre><code>第四部
    **4、经过 3 条点集**
        0 -&gt; &#123;1, 2, 3&#125; -&gt; 0    (4.1.13)
            0 -&gt; 1 -&gt; &#123;2,3&#125; -&gt; 0    (4.1.13.1)
            0 -&gt; 2 -&gt; &#123;1,3&#125; -&gt; 0    (4.1.13.2)
            0 -&gt; 3 -&gt; &#123;1,2&#125; -&gt; 0    (4.1.13.3)</code></pre>
<p>0 -&gt; {1, 2, 3} -&gt; 0，表示从点 0 出发，经过点集 1，2，3 最终回到出发点 0，</p>
<p>这就是我们要求的最短路径(因为 TSP 算法要求我们必须从 0 出发，经过多有得点，最后再回到 0 点)</p>
<p>此时我们有三种方式可以实现该过程，即上式得 (4.1.13.1),(4.1.13.2) 和 (4.1.13.3)</p>
<p>(4.1.13.1) 表示先从点 0 出发，到达点 1，然后经过点集 2 3，最后到达起始点 0；</p>
<p>(4.1.13.2) 表示先从点 0 出发，到达点 2，然后经过点集 1 3，最后到达起始点 0；</p>
<p>(4.1.13.2) 表示先从点 0 出发，到达点 3，然后经过点集 1 2，最后到达起始点 0；</p>
<p>因为要实现 0 -&gt; {1, 2, 3} -&gt; 0 这个过程，有三种方式，而我们要求的是最短路径，</p>
<p>所以要求得 0 -&gt; {1, 2, 3} -&gt; 0 最短路径为 </p>
<p>0 -&gt; 1 -&gt; {2,3} -&gt; 0，0 -&gt; 2 -&gt; {1,3} -&gt; 0 和 0 -&gt; 3 -&gt; {1,2} -&gt; 0 得最小值</p>
<p>对于 (4.1.13.1) 可以分解为两个过程，第一个过程为 0 -&gt; 1，第二个过程为 1 -&gt; {2，3} -&gt; 0</p>
<p>即先从点 0 出发，经过点 1，在经过点集 2 3，最后到达起始点 0</p>
<p>第一部分为矩阵 C[0][1] = 3 的值</p>
<p>而第二部分也已经求解，即 (4.4.10) 的结果 d(1,{2,3}) = 7</p>
<p>所以 1 -&gt; 2 -&gt; {3} -&gt; 0 = C[0][1] + d(1,{2,3}) = 3 + 7 = 10 </p>
<p>对于 (4.1.13.2) 可以分解为两个过程，第一个过程为 0 -&gt; 2，第二个过程为 2 -&gt; {1，3} -&gt; 0</p>
<p>即先从点 0 出发，经过点 2，在经过点集 1 3，最后到达起始点 0</p>
<p>第一部分为矩阵 C[0][2] = 6 的值</p>
<p>而第二部分也已经求解，即 (4.4.11) 的结果 d(2,{1,3}) = 10</p>
<p>所以 1 -&gt; 2 -&gt; {3} -&gt; 0 = C[0][2] + d(2,{1,3}) = 6 + 10 = 16</p>
<p>对于 (4.1.13.3) 可以分解为两个过程，第一个过程为 0 -&gt; 3，第二个过程为 3 -&gt; {1，2} -&gt; 0</p>
<p>即先从点 0 出发，经过点 3，在经过点集 1 2，最后到达起始点 0</p>
<p>第一部分为矩阵 C[0][3] = 7 的值</p>
<p>而第二部分也已经求解，即 (4.4.12) 的结果 d(3,{1,2}) = 14</p>
<p>所以 1 -&gt; 2 -&gt; {3} -&gt; 0 = C[0][3] + d(3,{1,2}) = 7 + 14 = 21</p>
<p>整理得，</p>
<pre><code>(4.1.13.1) : C[0][1] + d(1,&#123;2,3&#125;) = 3 + 7 = 10 
(4.1.13.2) : C[0][2] + d(2,&#123;1,3&#125;) = 6 + 10 = 16
(4.1.13.3) : C[0][3] + d(3,&#123;1,2&#125;) = 7 + 14 = 21
取最小值得
(4.1.13) ： min((4.1.13.1),(4.1.13.2),(4.1.13.3)) = 10 记为 d(0,&#123;1,2,3&#125;) = 10(4.4.13)</code></pre>
<p><strong>5、整理数据</strong></p>
<p>整理上方数据我们可以得到图 3 所示得表格，使用 dp 来表示这个二维数组</p>
<p><img src="https://clay-nuyoah.github.io/post-images/2020-11-25/o_image_thumb_1.png"></p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>&emsp;&emsp;&emsp;&emsp;图 3</p>
<p>其中 d[i][j] 表示点 i 通过 j 所表示得点集，然后回到 0 所得到的最短路径</p>
<p>dp[1][6](两个下标都是从 0 开始) 其中 1 表示节点 1 ，6 表示点集{2，3}</p>
<p>dp[1][6] 表示从点 1 出发，经过点集 {2,3} 最后到达 0 求得的最短路径为 7</p>
<h1 id="五、分析过程存在的难点"><a href="#五、分析过程存在的难点" class="headerlink" title="五、分析过程存在的难点"></a>五、分析过程存在的难点</h1><p><strong>1、如何表示 j 所代表的数据</strong></p>
<p>j 所代表的数据即,{},{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}</p>
<p>要想表示上边的点集，我们需要使用二进制形式表示，由于点集最多有三个点，</p>
<p>可以使用三位二进制来表示，具体表示方法为二进制从低位到高位依次表示 1 2 3，</p>
<p><img src="https://clay-nuyoah.github.io/post-images/2020-11-25/20201127113614.png"></p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;图 4</p>
<p>第 1 行第 2 列表示每位所代表的数字(行列下标都是从 1 开始)，</p>
<p>如第 5 行(下标从 1 开始) 0 1 1，从<em>右到左以</em>此表示 1 存在，2 存在，3不存在，</p>
<p>所以 011 表示点集{1,2}</p>
<p>这样我们就能用数字表示点集了</p>
<p>由于点集出现的顺序和图 3 的 j 所代表的顺序是不一致的，</p>
<p>所以需要重新绘制图 3 得到图 5，如下</p>
<p><img src="https://clay-nuyoah.github.io/post-images/2020-11-25/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201123113626.png"></p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;图 5</p>
<p>该图也将那些需要赋值为空的数据，赋值为 ∞，表示该点不可达,</p>
<p>我们将在下面介绍如何找到这些点</p>
<h1 id="六、对图中数据生成的过程进行说明"><a href="#六、对图中数据生成的过程进行说明" class="headerlink" title="六、对图中数据生成的过程进行说明"></a>六、对图中数据生成的过程进行说明</h1><h2 id="1、必备基础知识-以下所有的讨论都是基于图-5-红框中的数据，行列下标都从-0-开始"><a href="#1、必备基础知识-以下所有的讨论都是基于图-5-红框中的数据，行列下标都从-0-开始" class="headerlink" title="1、必备基础知识 (以下所有的讨论都是基于图 5 红框中的数据，行列下标都从 0 开始)##"></a>1、必备基础知识 (以下所有的讨论都是基于图 5 红框中的数据，行列下标都从 0 开始)##</h2><p><strong>1、可以通过整数来表示一个点集</strong></p>
<p>在图 4 中，可以通过一个整数找到对应的点集，对应关系如下</p>
<pre><code>0 = 000 -&gt; &#123;&#125;        1 = 001 -&gt; &#123;1&#125;
2 = 010 -&gt; &#123;2&#125;        3 = 011 -&gt; &#123;1,2&#125;
4 = 100 -&gt; &#123;3&#125;        5 = 101 -&gt; &#123;1,3&#125;
6 = 110 - &gt; &#123;2,3&#125;    7 = 111 -&gt; &#123;1,2,3&#125;

这说明我可以通过一个整数，找到对应的点集
例如 整数 6 就可以找到点集 &#123;2,3&#125;

同样，给定一个点集，也可以找到他在数组中对应的横坐标
如点集 &#123;1,3&#125; 二进制表示形式为 101 = 5,所以他在二维数组的横坐标为 5</code></pre>
<p><strong>2、dp[i][j] = num 表示的是什么</strong></p>
<p>dp[i][j] = num 表示的是从点 i 出发，经过 j 所表示的点集 V’，</p>
<p>到达 0 的最短距离为 num，即 d(i,V’) 的最短距离为 num</p>
<p>如 d[3][3] = 14 表示从 3 出发，经过 3 所表示的点集{1,2}，</p>
<p>到达 0 的最短距离为 14，即 d(3,{1,2}) = 14</p>
<p><strong>3、如何判断整数 num 的二进制表示形式的第 j 位上为 1（以8位二进制数为例）</strong></p>
<pre><code>通过 num &amp; 0000 0001 
    结果为 0000 0001(2的0次方) num 的第 1 位上存在 1，为 0 不存在
通过 num &amp; 0000 0010 
    结果为 0000 0010(2的1次方) num 的第 2 位上存在 1，为 0 不存在
通过 num &amp; 0000 0100 
    结果为 0000 0100(2的2次方) num 的第 3 位上存在 1，为 0 不存在
通过 num &amp; 0000 1000 
    结果为 0000 1000(2的3次方) num 的第 4 位上存在 1，为 0 不存在
通过 num &amp; 0001 0000 
    结果为 0001 0000(2的4次方) num 的第 5 位上存在 1，为 0 不存在
通过 num &amp; 0010 0000 
    结果为 0010 0000(2的5次方) num 的第 6 位上存在 1，为 0 不存在
通过 num &amp; 0100 0000 
    结果为 0100 0000(2的6次方) num 的第 7 位上存在 1，为 0 不存在
通过 num &amp; 1000 0000 
    结果为 1000 0000(2的7次方) num 的第 8 位上存在 1，为 0 不存在</code></pre>
<p>例如对于 252 二进制为 1010 1010</p>
<pre><code>第 1 位    1010 1010 &amp; 0000 0001 = 0000 0000
第 2 位    1010 1010 &amp; 0000 0010 = 0000 0010
第 3 位    1010 1010 &amp; 0000 0100 = 0000 0000
第 4 位    1010 1010 &amp; 0000 1000 = 0000 1000
第 5 位    1010 1010 &amp; 0001 0000 = 0000 0000
第 6 位    1010 1010 &amp; 0010 0000 = 0010 0000
第 7 位    1010 1010 &amp; 0100 0000 = 0000 0000
第 8 位    1010 1010 &amp; 1000 0000 = 1000 0000
可以得出 252 这个整数的第 2，4，6，8 位上面各存在一个 1
                     而 1，3，5，7 位上面没有 1，与 252 的二进制表示形式相符</code></pre>
<p><strong>4、第 j 位上的 1 代表的是哪个点</strong></p>
<p><em>直接说结论，第 j 位上的 1 代表的是 j 这个点</em><br>因为从左到右以此表示的点为 1 2 3 4 ……</p>
<p>例如对于 252 二进制为 1010 1010</p>
<pre><code>1010 1010 第 2 位存在 1 ，代表点 2
1010 1010 第 4 位存在 1 ，代表点 4
1010 1010 第 6 位存在 1 ，代表点 6
1010 1010 第 8 位存在 1 ，代表点 8</code></pre>
<p><strong>5、如何判断点 k 是否存在于点集之中</strong></p>
<p>还是直接说结论，若点集的整数表示形式为 pointNum,则点 k 存在于点集中，</p>
<p>必有如下规则 pointNum &amp; 2^(k - 1) = 2^(k - 1)</p>
<p>例如对于 252 二进制为1010 1010</p>
<pre><code>1010 1010 &amp; 0000 0010 = 0000 0010 表示点 2 在点集中(0000 0010 = 2^(2 - 1))
1010 1010 &amp; 0000 1000 = 0000 1000 表示点 4 在点集中(0000 1000 = 2^(4 - 1))
1010 1010 &amp; 0010 0000 = 0010 0000 表示点 6 在点集中(0010 0000 = 2^(6 - 1))
1010 1010 &amp; 1000 0000 = 1000 0000 表示点 8 在点集中(1000 0000 = 2^(8 - 1))</code></pre>
<p><strong>6、从点集中取出一个点后形成一个新的点集</strong></p>
<p>可以先通过 <strong>5</strong> 判断在点集中是否存在一个点，若存在，则移除该点，</p>
<p>可以通过如下的方法从点集中移除该点</p>
<p>选择点集 V’ 用整数 pointNum 表示，判断一个点是否在点集里面，若存在，取出该点，</p>
<p>获得新的点集 V’’ 用整数 newPointNum 表示，获取一个新的点集的过程如下</p>
<pre><code>1、
    判断点集中是否存在 1 点
    pointNum &amp; 0000 0001(2的 0 次方) = 0000 0001
    获取新的点集(若点 1 存在点集中，则执行下列步骤，否则判断点 2)
    pointNum - 0000 0001 = newPointNum
    newPointNum 就是新的点集的整数表示形式
2、
    判断点集中是否存在 2 点
    pointNum &amp; 0000 0010(2的 1 次方) = 0000 0010
    获取新的点集(若第 2 位上存在 1，则执行下列步骤，否则判断点 3)
    pointNum - 0000 0010 = newPointNum
    newPointNum 就是新的点集的整数表示形式

                    ………………

i、
    判断点集中是否存在 i 点
    pointNum &amp; 1(i 个 0)(2的 i - 1 次方) = 1(i 个 0)
    获取新的点集(若第 i 位上存在 1，则执行下列步骤，否则判断点 i + 1)
    pointNum - 1(i 个 0) = newPointNum
    newPointNum 就是新的点集的整数表示形式</code></pre>
<p>例如对于 252 二进制为 1010 1010</p>
<pre><code>1010 1010 &amp; 0000 0001 = 0000 0000 第 1 位没有 1
1010 1010 &amp; 0000 0010 = 0000 0010 第 2 位存在 1
    1010 1010 - 0000 0010 = 1010 1000 新点集 1010 1000

1010 1010 &amp; 0000 0100 = 0000 0000 第 3 位没有 1
1010 1010 &amp; 0000 1000 = 0000 1000 第 4 位存在 1
    1010 1010 - 0000 1000 = 1010 0010 新点集 1010 0010

1010 1010 &amp; 0001 0000 = 0000 0000 第 5 位没有 1
1010 1010 &amp; 0010 0000 = 0010 0000 第 6 位存在 1
    1010 1010 - 0010 0000 = 1000 1010 新点集 1000 1010

1010 1010 &amp; 0100 0000 = 0000 0000 第 7 位没有 1
1010 1010 &amp; 1000 0000 = 1000 0000 第 8 位存在 1
    1010 1010 - 1000 0000 = 0010 1010 新点集 0010 1010</code></pre>
<p><strong>7、d(i,V’)的另外一种表示</strong></p>
<p>d(i,V’) 表示从点 i 出发,经过点集 V’ （使用整数 pointNum 表示）,</p>
<p>到达点 0 的最短距离（假设在 pointNum 的二进制表示形式中第 j 位上存在 1）</p>
<p>由 2 知，</p>
<p>dp[i][pointNum] 表示的是从点 i 出发，经过 pointNum 所表示的点集 V’，</p>
<p>到达点 0 的最短距离。</p>
<p>因此可以看出 d(i,V’) = dp[i][pointNum] (在 pointNum 能够表示 V’ 的情况下)</p>
<p><strong>8、拆分之后如何求最短路径</strong></p>
<p>最短路径 d(i,V’) 表示从点 i 出发,经过点集 V’ （使用整数 pointNum 表示）,</p>
<p>最后到达 0 的最短距离（假设在 pointNum 的二进制表示形式中第 j 位上存在 1）</p>
<p>我们可以通过 3 判断出在 pointNum 的第 j 位上存在 1,</p>
<p>然后我们通过 6 可以取出点 j </p>
<p>那么取出的点为 k （2 的 j - 1 次方），构成的新点集为 V’’ 用整数 newPointNum 表示</p>
<p>那么我们就获得了一条新的路径，新路径为 i -&gt; j -&gt; V’’ -&gt; 0</p>
<p>表示为 从点 i 出发，然后到达点 j，然后从点 j(2 的 j - 1 次方) 出发，</p>
<p>绕后经过点集 V’’,最后到达 0 点的最短路径，拆分为两部分</p>
<pre><code>第一部分 i -&gt; j 表示从 i 到 j 的距离，可以通过 C[i][j] 表示
第二部分 j -&gt; V&#39;&#39; -&gt; 0 j 经过点集 V&#39;&#39; 最后到达 0 的距离
可以通过 dp[j][newPointNum] 表示

由 2 可知，
dp[i][j] 表示的是从点 i 出发，经过 j 所表示的点集 V&#39;，然后到达 0 的最短距离，
那么 dp[j][newPointNum] 表示的是从点 j 出发，
经过 newPointNum 所表示的点集 V&#39;&#39;，然后到达 0 的最短距离,
所以 j -&gt; V&#39;&#39; -&gt; 0 可以使用 dp[j][newPointNum] 来表示</code></pre>
<p>因此,</p>
<p>d(i,V’) = dp[i][pointNum] = i -&gt; V’ -&gt; 0 = i -&gt; j -&gt; V’’ -&gt; 0 = C[i][j] + dp[j][newPointNum]</p>
<p>其中 i 是已知的不用求，k = 2^(j -1)，newPointNum = pointNum - k</p>
<p>pointNum 也是已知的，它是 V’ 的整数表示形式，</p>
<p>那么我们只需要找出 j 和 newPointNum 就行了</p>
<p>当我们知道了 j 时，k 就已知， newPointNum 也就已知，所以主要求 j</p>
<p>例如，由 6 可知，对于图 5 的 dp[3][3] = d(3,{1,2}) = 14</p>
<pre><code>其中 i = 3，pointNum = 011 = 3
    第 1 位 第 2 位 第 3 位
    011        011        011
   &amp;001       &amp;010       &amp;100
    001        010        000

得到 
    j1 = 1                               j2 = 2(表示第 1 2 位上存在 1)
    k1 = 2^(1-1) = 1                    k2 = 2^(2 - 1) = 2(表示点 1 2 在点集中)
    newPointNum1 = pointNum - k1 = 2    newPointNum2 = pointNum - k2 = 1
    C[3][1] + dp[1][2] = 7 + 8 = 15        C[3][2] + dp[2][1] = 5 + 9 = 14

两者取最小值为14，即为数组 dp[3][3] 所求
dp[1][2],dp[2][1]我们会在下面介绍如何得到的</code></pre>
<p><strong>9、如何找出无效的点</strong></p>
<p>无效的点分为两种情况，</p>
<ul>
<li>没有经过完整的点集</li>
<li>经过了重复的点</li>
</ul>
<p>将 dp 中的无效点进行分类，可以得到下列数据</p>
<pre><code>对于第一种在 dp 数组中有点
    dp[0][0],dp[0][1],dp[0][2]dp[0][3],dp[0][4],dp[0][5],dp[0][6]
    有这 7 个点
对于第 2 种情况在 dp 数组中有点
    dp[1][1],dp[1][3],dp[1][5],dp[1][7]
    dp[2][2],dp[2][3],dp[2][6],dp[2][7]
    dp[3][4],dp[3][5],dp[3][6],dp[3][7]
    有这 12 个点

第一种情况可以通过 if 判断，当在 0 行时，是否为最后一列，若不是最后一列，
就赋值为无效值
对于第二种情况,由于是经过了重复的点，通过 5 我们可以判断在点集中是否存在一个点，
这时候我们只需要知道判断的是哪个点在不在点击就可以了
对于dp[i][j] 来说，只需要判断 i 是不是在点集中就好了，

dp[1][1] k = 2^(1 - 1) = 1        j &amp; k = 001 &amp; 001 = 001
表示在点集中存在 1
dp[1][3] k = 2^(1 - 1) = 1        j &amp; k = 011 &amp; 001 = 001
表示在点击中存在 1
dp[1][5] k = 2^(1 - 1) = 1        j &amp; k = 101 &amp; 001 = 001
表示在点集中存在 1
dp[1][7] k = 2^(1 - 1) = 1        j &amp; k = 111 &amp; 001 = 001
表示在点集中存在 1

dp[2][2] k = 2^(2 - 1) = 2        j &amp; k = 010 &amp; 010 = 010
表示在点集中存在 2
dp[2][3] k = 2^(2 - 1) = 2        j &amp; k = 011 &amp; 010 = 010
表示在点击中存在 2
dp[2][6] k = 2^(2 - 1) = 2        j &amp; k = 110 &amp; 010 = 010
表示在点集中存在 2
dp[2][7] k = 2^(2 - 1) = 2        j &amp; k = 111 &amp; 010 = 010
表示在点集中存在 2

dp[3][4] k = 2^(3 - 1) = 4        j &amp; k = 100 &amp; 100 = 100
表示在点集中存在 3
dp[3][5] k = 2^(3 - 1) = 4        j &amp; k = 101 &amp; 100 = 100
表示在点击中存在 3
dp[3][6] k = 2^(3 - 1) = 4        j &amp; k = 110 &amp; 100 = 100
表示在点集中存在 3
dp[3][7] k = 2^(3 - 1) = 4        j &amp; k = 111 &amp; 100 = 100
表示在点集中存在 3</code></pre>
<h2 id="2、表格数据进行说明-只要我们能够找到-k-就可以解决问题了"><a href="#2、表格数据进行说明-只要我们能够找到-k-就可以解决问题了" class="headerlink" title="2、表格数据进行说明(只要我们能够找到 k 就可以解决问题了)##"></a>2、表格数据进行说明(只要我们能够找到 k 就可以解决问题了)##</h2><p>我们在 9、如何找出无效的点章节已经找出了无效的点，下面的讨论将会一笔带过，</p>
<p>它们分别是 </p>
<pre><code>dp[0][0],dp[0][1],dp[0][2],dp[0][3],
dp[0][4],dp[0][5],dp[0][6]
dp[1][1],dp[1][3],dp[1][5],dp[1][7]
dp[2][2],dp[2][3],dp[2][6],dp[2][7]
dp[3][4],dp[3][5],dp[3][6],dp[3][7]</code></pre>
<p>对红框框起来的数据进行讨论    </p>
<p>第 0 列数据</p>
<pre><code>dp[0][0] = ∞ 已经证明
dp[1][0] = d(1,&#123;&#125;) = C[1][0] = 5
dp[2][0] = d(2,&#123;&#125;) = C[2][0] = 6
dp[3][0] = d(3,&#123;&#125;) = C[3][0] = 3</code></pre>
<p>这一行的数据可以在初始化的时候给表格赋值初始值</p>
<p>第 1 列数据</p>
<pre><code>dp[0][1] = ∞ 已经证明
dp[1][1] = ∞ 已经证明
dp[2][1] = d(2,&#123;1&#125;)
    其中 i = 2，pointNum = 001 = 1
    第 1 位 第 2 位 第 3 位
    001        001        001
   &amp;001       &amp;010       &amp;100
    001        000        000 
得到 
    j = 1                               
    k = 2^(1 - 1) = 1                    
    newPointNum = pointNum - k = 0    
    C[2][1] + dp[1][0] = 4 + 5 = 9

dp[3][1] = d(3,&#123;1&#125;)
    其中 i = 3，pointNum = 001 = 1
    第 1 位 第 2 位 第 3 位
    001        001        001
   &amp;001       &amp;010       &amp;100
    001        000        000 
得到 
    j = 1                               
    k = 2^(1 - 1) = 1                    
    newPointNum = pointNum - k = 0    
    C[3][1] + dp[1][0] = 7 + 5 = 12    </code></pre>
<p>第 2 列数据</p>
<pre><code>dp[0][2] = ∞ 已经证明
dp[1][2] = d(1,&#123;2&#125;)
其中 i = 1，pointNum = 010 = 2
    第 1 位 第 2 位 第 3 位
    010        010        010
   &amp;001       &amp;010       &amp;100
    000        010        000 
得到 
    j = 2                               
    k = 2^(2 - 1) = 2                    
    newPointNum = pointNum - k = 0    
    C[1][2] + dp[2][0] = 2 + 6 = 8    
dp[2][2] = ∞ 已经证明
dp[3][2] = d(3,&#123;2&#125;)
    其中 i = 3，pointNum = 010 = 2
    第 1 位 第 2 位 第 3 位
    010        010        010
   &amp;001       &amp;010       &amp;100
    000        010        000 
得到 
    j = 2                               
    k = 2^(2 - 1) = 2                    
    newPointNum = pointNum - k = 0    
    C[3][2] + dp[2][0] = 5 + 6 = 11    </code></pre>
<p>第 4 列（注意这里是第 4 列，不是第 3 列，先把单个点集的列计算完）</p>
<pre><code>dp[0][4] = ∞ 已经证明
dp[1][4] = d(1,&#123;3&#125;)
    其中 i = 1，pointNum = 100 = 4
    第 1 位 第 2 位 第 3 位
    100        100        100
   &amp;001       &amp;010       &amp;100
    000        000        100 
得到 
    j = 3                               
    k = 2^(3 - 1) = 4                    
    newPointNum = pointNum - k = 0    
    C[1][3] + dp[3][0] = 3 + 3 = 6    
dp[2][4] = d(2,&#123;3&#125;)
    其中 i = 2，pointNum = 100 = 4
    第 1 位 第 2 位 第 3 位
    100        100        100
   &amp;001       &amp;010       &amp;100
    000        000        100 
得到 
    j = 3                               
    k = 2^(3 - 1) = 4                    
    newPointNum = pointNum - k = 0    
    C[2][3] + dp[3][0] = 2 + 3 = 5    
dp[3][4] = ∞ 已经证明</code></pre>
<p>第 3 列数据</p>
<pre><code>dp[0][3] = ∞ 已经证明
dp[1][3] = ∞ 已经证明
dp[2][3] = ∞ 已经证明
dp[3][3] = d(2,&#123;1,2&#125;) (上面也已经证明,摘录一下)
其中 i = 3，pointNum = 011 = 3
    第 1 位 第 2 位 第 3 位
    011        011        011
   &amp;001       &amp;010       &amp;100
    001        010        000

得到 
    j1 = 1                               j2 = 2(表示第 1 2 位上存在 1)
    k1 = 2^(1-1) = 1                    k2 = 2^(2 - 1) = 2(表示点 1 2 在点集中)
    newPointNum1 = pointNum - k1 = 2    newPointNum2 = pointNum - k2 = 1
    C[3][1] + dp[1][2] = 7 + 8 = 15        C[3][2] + dp[2][1] = 5 + 9 = 14

两者取最小值为14，即为数组 dp[3][3] 所求</code></pre>
<p>第 5 列数据</p>
<pre><code>dp[0][5] = ∞ 已经证明
dp[1][5] = ∞ 已经证明
dp[2][5] = d(2,&#123;1,3&#125;)
其中 i = 2，pointNum = 101 = 5
    第 1 位 第 2 位 第 3 位
    101        101        101
   &amp;001       &amp;010       &amp;100
    001        000        100

得到 
    j1 = 1                               j2 = 3(表示第 1 2 位上存在 1)
    k1 = 2^(1 - 1) = 1                    k2 = 2^(3 - 1) = 4(表示点 1 2 在点集中)
    newPointNum1 = pointNum - k1 = 4    newPointNum2 = pointNum - k2 = 1
    C[2][1] + dp[1][4] = 4 + 6 = 10        C[2][3] + dp[3][1] = 2 + 12 = 14
    两者取最小值为10，即为数组 dp[2][5] 所求
dp[3][5] = ∞ 已经证明</code></pre>
<p>第 6 列数据</p>
<pre><code>dp[0][6] = ∞ 已经证明
dp[1][6] = d(1,&#123;2,3&#125;)
其中 i = 1，pointNum = 110 = 6
    第 1 位 第 2 位 第 3 位
    110        110        110
   &amp;001       &amp;010       &amp;100
    000        010        100

得到 
    j1 = 2                               j2 = 3(表示第 1 2 位上存在 1)
    k1 = 2^(2 - 1) = 2                    k2 = 2^(3 - 1) = 4(表示点 1 2 在点集中)
    newPointNum1 = pointNum - k1 = 4    newPointNum2 = pointNum - k2 = 2
    C[1][2] + dp[2][4] = 2 + 5 = 7        C[1][3] + dp[3][2] = 3 + 11 = 14    
    两者取最小值为7，即为数组 dp[1][5] 所求
dp[2][6] = ∞ 已经证明
dp[3][6] = ∞ 已经证明</code></pre>
<p>第 7 列数据</p>
<pre><code>dp[0][7] = d(0,&#123;1,2,3&#125;) 这个是有数据的，因为经过了所有的点集
    其中 i = 0，pointNum = 111 = 7
    第 1 位 第 2 位 第 3 位
    111        111        111
   &amp;001       &amp;010       &amp;100
    001        010        100

得到 
    j1 = 1                   j2 = 2                                                j3 = 3
    k1 = 1                    k2 = 2                                                k3 = 4
    newPointNum1  = 6        newPointNum2 = 5                                    newPointNum2 = 3
    C[0][1] + dp[1][6] = 3 + 7 = 10        C[0][2] + dp[2][5] = 6 + 10 = 16  C[0][3] + dp[3][3] = 7 + 14 = 21
    三者取最小值为10，即为数组 dp[0][7] 所求</code></pre>
<p>整个数组就这样讲解完了</p>
<h1 id="七、代码讲解"><a href="#七、代码讲解" class="headerlink" title="七、代码讲解"></a>七、代码讲解</h1><p>通过上面的讲解，我们知道要先求点的数量为 0 1 2 3 的点集，但是点集在横坐标上并不是按照数量进行排序的，而是按照点集的整数表现形式，从小到大进行排序的。如图 5 的第 3 列和第 4 列(下标从 0 开始)。</p>
<p>因此我们需要找到点的数量为 0 1 2 3 的点集，可以通过下面的代码进行求解，第一张图片显示了如何求解一个整数中 1 的数量，第 2 张图片显示，构造一个列表，该列表存储了有 0 个 1，1 个 1，2 个 1，3 个 1 的都有哪些列表，最终构造的列表如下<br>0    [0]<br>1    [1,2,4]<br>2    [3,5,6]<br>3    [7]</p>
<p>所代表的含义是，</p>
<pre><code>0 个 1 的整数有 0
1 个 1 的整数有 1,2,4
2 个 1 的整数有 3,5,6
3 个 1 的整数有 7</code></pre>
<p><img src="https://clay-nuyoah.github.io/post-images/2020-11-25/20201206204556.png"></p>
<p>如何从一个整数中获取 1 的个数，可以查看这篇博客，此处的代码片段也是从该博客中截取的</p>
<p>地址：<a href="https://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html">https://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html</a></p>
<p><img src="https://clay-nuyoah.github.io/post-images/2020-11-25/20201204211841.png"></p>
<p>在开始有个初始化的操作，因为在初始的时候我们就已经知道了，点集中点的个数有多少，</p>
<p>对于图 1，有 4 个点，去掉起始点 0(因为起始点不能加入到点集中)，剩余的 3 个点，</p>
<p>共有 4 种情况，0 个 1，1 个 1，2 个 1，3 个 1。</p>
<p><img src="https://clay-nuyoah.github.io/post-images/2020-11-25/20201204212242.png"></p>
<pre><code>1 处就是把无效数据给赋值成 ∞，这里用 Integer.MAX_VALUE 代替
2 处判断一个点是都存在点集中，并且拆出来的这个点能够由 i 点可达
3 处进行点的拆分
4 处当拆分出多个点的时候，取其最小值</code></pre>
<h1 id="八、代码"><a href="#八、代码" class="headerlink" title="八、代码"></a>八、代码</h1><p>代码地址:<a href="https://github.com/clay-nuyoah/TSP" title="TSP代码地址">https://github.com/clay-nuyoah/TSP</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package tsp;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * TSP 算法旅行推销员问题</span><br><span class="line"> * 给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TspDp &#123;</span><br><span class="line">	    public static void main(String[] args) &#123;</span><br><span class="line">	        int[][] nums &#x3D; &#123;&#123;Integer.MAX_VALUE, 3, 6, 7&#125;,</span><br><span class="line">	                &#123;5, Integer.MAX_VALUE, 2, 3&#125;,</span><br><span class="line">	                &#123;6, 4, Integer.MAX_VALUE, 2&#125;,</span><br><span class="line">	                &#123;3, 7, 5, Integer.MAX_VALUE&#125;</span><br><span class="line">	        &#125;;</span><br><span class="line">	        TspDp tspDp &#x3D; new TspDp();</span><br><span class="line">	        int minCost &#x3D; tspDp.getMinCost(nums, nums.length);</span><br><span class="line">	        System.out.println(minCost);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取最小花费</span><br><span class="line">     *</span><br><span class="line">     * @param nums 节点之间的花费</span><br><span class="line">     * @param n    节点个数</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int getMinCost(int[][] nums, int n) &#123;</span><br><span class="line">        int row &#x3D; n;</span><br><span class="line">        int col &#x3D; (int) Math.pow(2, n - 1);</span><br><span class="line">        int[][] dp &#x3D; new int[row][col];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; countLists &#x3D; getCountLists(row, col);</span><br><span class="line"></span><br><span class="line">        init(dp, nums, row);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;遍历数组中的每一个数</span><br><span class="line">        for (int j &#x3D; 1; j &lt; row; j++) &#123; &#x2F;&#x2F;循环遍历 数量 数组</span><br><span class="line">            List&lt;Integer&gt; countList &#x3D; countLists.get(j);</span><br><span class="line">				&#x2F;&#x2F;用来确定横坐标</span><br><span class="line">            for (int k &#x3D; 0; k &lt; countList.size(); k++) &#123;</span><br><span class="line">				&#x2F;&#x2F;纵坐标       </span><br><span class="line">                for (int i &#x3D; 0; i &lt; row; i++) &#123;           </span><br><span class="line">                    Integer num &#x3D; countList.get(k);</span><br><span class="line">                    int currentMinCost &#x3D; getCurrentMinCost(i, num, row, col, nums, dp);</span><br><span class="line">                    dp[i][num] &#x3D; currentMinCost;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; col; j++) &#123;</span><br><span class="line">                System.out.print(dp[i][j] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][col - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取一个 list</span><br><span class="line">     * list[0] 表示 从 0 ~ col 中二进制 拥有 0 个 1 的数字组成的集合</span><br><span class="line">     * list[1] 表示 从 0 ~ col 中二进制 拥有 1 个 1 的数字组成的集合</span><br><span class="line">     *</span><br><span class="line">     * @param row</span><br><span class="line">     * @param col</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; getCountLists(int row, int col) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; countLists &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; row; i++) &#123;</span><br><span class="line">            countLists.add(new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; col; i++) &#123;</span><br><span class="line">            int count &#x3D; bitCount(i);</span><br><span class="line">            countLists.get(count).add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return countLists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取一个整数 二进制 1 的个数</span><br><span class="line">     *</span><br><span class="line">     * @param n</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int bitCount(int n) &#123;</span><br><span class="line">        int c;</span><br><span class="line">        for (c &#x3D; 0; n !&#x3D; 0; ++c) &#123;</span><br><span class="line">            n &amp;&#x3D; (n - 1); &#x2F;&#x2F; 清除最低位的1</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取当前条件下的最小花费</span><br><span class="line">     *</span><br><span class="line">     * @param i</span><br><span class="line">     * @param num</span><br><span class="line">     * @param row</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int getCurrentMinCost(int i, int num, int row, </span><br><span class="line">			int col, int[][] nums, int[][] dp) &#123;</span><br><span class="line">        int pow &#x3D; (int) Math.pow(2, i - 1);</span><br><span class="line"></span><br><span class="line">        if (num !&#x3D; col - 1 &amp;&amp; (i &#x3D;&#x3D; 0 || (pow &amp; num) &#x3D;&#x3D; pow)) &#123;</span><br><span class="line">            return Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int min &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        for (int j &#x3D; 1; j &lt; row; j++) &#123;</span><br><span class="line">            int pow1 &#x3D; (int) Math.pow(2, j - 1);</span><br><span class="line">            if ((pow1 &amp; num) &#x3D;&#x3D; pow1 &amp;&amp; nums[i][j] !&#x3D; Integer.MAX_VALUE) &#123;</span><br><span class="line">                int y &#x3D; num - pow1;</span><br><span class="line">                int cost &#x3D; nums[i][j] + dp[j][y];</span><br><span class="line">                if (cost &lt; min) &#123;</span><br><span class="line">                    min &#x3D; cost;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 初始化 dp</span><br><span class="line">     *</span><br><span class="line">     * @param dp</span><br><span class="line">     * @param nums</span><br><span class="line">     * @param row</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void init(int[][] dp, int[][] nums, int row) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; row; i++) &#123;</span><br><span class="line">            dp[i][0] &#x3D; nums[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>dp</tag>
        <tag>动态规划</tag>
        <tag>算法</tag>
        <tag>TSP</tag>
      </tags>
  </entry>
  <entry>
    <title>方向选择</title>
    <url>/2021/03/08/fang-xiang-xuan-ze/</url>
    <content><![CDATA[<p>从几篇文章中选一下研究方向，简单看下三篇文章的摘要</p>
<a id="more"></a>

<h1 id="1、A-Survey-on-Multi-Label-Data-Stream-Classification"><a href="#1、A-Survey-on-Multi-Label-Data-Stream-Classification" class="headerlink" title="1、A Survey on Multi-Label Data Stream Classification"></a>1、A Survey on Multi-Label Data Stream Classification</h1><p>题目：多标签数据流分类研究</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/fang-xiang-xuan-ze/2021/03/08/19-24-58-5e43a376d1da6b50629fdbc293f410c4-A%20Survey%20on%20Multi-Label%20Data%20Stream%20Classification_abstract-7cd420.png"></p>
<p>摘要：如今，我们日常生活中的许多现实应用都产生了大量的流数据，产生数据的速度比以往任何时候都高，仅举几个例子，即 Web 点击数据流，感知网络数据和信用交易流。与使用静态数据集的传统数据挖掘相反，数据流挖掘有几个挑战，例如有限的内存，一站式及时响应。在这项调查中，我们对现有的多标签流挖掘算法进行了全面的回顾，并根据不同的角度对这些方法进行分类，主要集中在多标签数据流分类。我们首先简要概述现有的多标签和数据流分类算法，以及讨论他们的优点和缺点。其次，我们确定了多标签流数据分类的挖掘约束，并提出了对多标签数据流分类算法的全面研究。最后，讨论了多标签数据流分类中的一些挑战和未解决的问题，这些都是值得今后研究人员继续探索的。</p>
<p>关键字：数据流挖掘;多标签数据;多标签分类</p>
<p>流数据：流数据是由不同来源连续生成的数据</p>
<h1 id="2、Information-Security-in-Big-Data-Privacy-and-Data-Mining"><a href="#2、Information-Security-in-Big-Data-Privacy-and-Data-Mining" class="headerlink" title="2、Information Security in Big Data: Privacy and Data Mining"></a>2、Information Security in Big Data: Privacy and Data Mining</h1><p>题目：大数据中的信息安全：隐私和数据挖掘</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/fang-xiang-xuan-ze/2021/03/08/19-27-26-921f9c899880f484ed0ca731f07be320-Information%20Security%20in%20Big%20Data%20Privacy%20and%20Data%20Mining_abstract-3715a4.png"></p>
<p>摘要：数据挖掘技术的日益普及和发展对个人敏感信息的安全性构成了严重威胁。数据挖掘中的一个新兴研究主题，即隐私保护数据挖掘（PPDM），近年来已经得到了广泛的研究。PPDM的基本思想是修改数据，以便有效地执行数据挖掘算法，而不会损害数据中包含的敏感信息的安全性。PPDM的当前研究主要集中在如何减少数据挖掘操作带来的隐私风险上，而实际上，在数据收集，数据发布和信息（即：数据挖掘的结果）传递过程中也可能发生不希望的敏感信息泄露。在本文中，我们从更广阔的角度看待与数据挖掘相关的隐私问题，并研究可以帮助保护敏感信息的各种方法。特别是，我们确定了四种不同类型的用户，它们是数据挖掘应用程序，即数据提供者，数据收集者，数据挖掘者和决策者。对于每种类型的用户，我们讨论他的隐私问题以及可以用来保护敏感信息的方法。我们简要介绍了相关研究主题的基础知识，回顾了最先进的方法，并对未来的研究方向提出了一些初步的想法。<br>除了探讨每种类型用户的隐私保护方法外，我们还回顾了博弈论方法，该方法旨在分析数据挖掘场景中不同用户之间的交互，每个人对敏感信息都有自己的评估。通过区分不同用户关于敏感信息安全方面的职责，我们希望提供一些对于PPDM研究有用见解。</p>
<p>关键字：数据挖掘;敏感信息;隐私保护数据挖掘;匿名化;追踪;博弈论;隐私拍卖;反追踪</p>
<h1 id="3、Mining-Conditional-Functional-Dependency-Rules-on-Big-Data"><a href="#3、Mining-Conditional-Functional-Dependency-Rules-on-Big-Data" class="headerlink" title="3、Mining Conditional Functional Dependency Rules on Big Data"></a>3、Mining Conditional Functional Dependency Rules on Big Data</h1><p>题目：在大数据上挖掘条件功能依赖规则</p>
<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/source/post-images/fang-xiang-xuan-ze/2021/03/08/19-10-58-9f4b91438594f4fde6de1df53a3a1dac-Mining%20Conditional%20Functional%20Dependency%20Rules%20on%20Big%20Data_abstract-bff334.png"></p>
<p>摘要：当前的条件功能依赖（CFD）发现算法始终需要准备充分的训练数据集。这种情况使它们难以应用于大型和低质量的数据集。为了处理大数据的体积问题，我们开发了采样算法来获得一个小的有代表性的训练集。我们设计了容错规则发现和冲突解决算法，以解决大数据的低质量问题。我们还提出了参数选择策略，以确保CFD发现算法的有效性。实验结果表明，我们的方法可以在合理的时间内发现数十亿元数据的有效CFD规则。</p>
<p>关键字：数据挖掘;条件功能依赖;大数据;数据质量</p>
]]></content>
      <tags>
        <tag>数据流挖掘</tag>
        <tag>多标签数据</tag>
        <tag>多标签分类</tag>
        <tag>数据挖掘</tag>
        <tag>敏感信息</tag>
        <tag>条件功能依赖</tag>
        <tag>大数据</tag>
        <tag>数据质量</tag>
      </tags>
  </entry>
  <entry>
    <title>skip-gram</title>
    <url>/2021/06/13/skip-gram/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/clay-nuyoah/ImageHosting@master/img/clay-nuyoah/Users/93497/Desktop/2021/06/13/10-49-14-4326e64fe0f495f6632be2093c165e8c-006Fmjmcly1fgco3v2ca7j30pq0j7drt%20-2--0670c6.jpg"></p>
<ol>
<li>$w_t$ 表示单词的 one-hot 编码  维度为 $V * 1$，$V$ 为文本中单词的个数</li>
<li>$W$ 表示中心词向量矩阵，是需要优化的变量，开始时随机初始化，维度为 $d * V$，$V$ 同上，$d$ 是超参数需要手动设置，一般在 50 - 300</li>
<li>$V_c$ 表示中心词向量，是由 $W$ 与 $w_t$ 做矩阵乘法的结果</li>
<li>$W’$ 表示上下文词向量矩阵，也是需要优化的变量，开始时随机初始化，维度为$V * d$。$V，d$ 同上</li>
<li>是 $W’$ 与 $V_c$ 做矩阵乘法得到的结果，维度为 $V * 1$，5 部分列举的 3 个向量是一样的</li>
<li>$P(x|c)$ 表示在 c 出现的前提下，x 出现的概率，条件概率函数定义为 softmax 函数，维度为 $V * 1$。在 6 中出现的 3 个向量也是一样的，向量的第 1 个数表示，在中心词 c 出现的条件下，第一个词出现的概率。</li>
<li>Truth 表示真实出现的词，7 中第 1 个向量表示，在中心词前面的第 3 个词，是 one-hot 编码的第 6 个词</li>
<li>根据 6，7 求损失</li>
<li>由梯度的的推导公式更新 $W$ 和 $W’$</li>
</ol>
]]></content>
  </entry>
</search>
